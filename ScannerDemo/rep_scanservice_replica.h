#ifndef REP_SCANSERVICE_REPLICA_H
#define REP_SCANSERVICE_REPLICA_H

// This is an autogenerated file.
// Do not edit this file, any changes made will be lost the next time it is generated.

#include <QtCore/qobject.h>
#include <QtCore/qdatastream.h>
#include <QtCore/qvariant.h>
#include <QtCore/qmetatype.h>

#include <QtRemoteObjects/qremoteobjectnode.h>
#include <QtRemoteObjects/qremoteobjectpendingcall.h>
#include <QtRemoteObjects/qremoteobjectreplica.h>

#include<QVariantList>

#include<QVariantMap>

#include<QTime>

#include<QVector>

#include<QVector3D>

#include<QPair>

class ActionResult
{
    Q_GADGET

    Q_PROPERTY(bool success READ success WRITE setSuccess)
    Q_PROPERTY(int error READ error WRITE setError)
    Q_PROPERTY(QString detail READ detail WRITE setDetail)
public:
    ActionResult() : _success(), _error(), _detail() {}
    explicit ActionResult(bool success, int error, QString detail) : _success(success), _error(error), _detail(detail) {}
    bool success() const { return _success; }
    void setSuccess(bool success) { if (success != _success) { _success = success; } }
    int error() const { return _error; }
    void setError(int error) { if (error != _error) { _error = error; } }
    QString detail() const { return _detail; }
    void setDetail(QString detail) { if (detail != _detail) { _detail = detail; } }
private:
    bool _success;
    int _error;
    QString _detail;
};

inline bool operator==(const ActionResult &left, const ActionResult &right) Q_DECL_NOTHROW {
    return left.success() == right.success() && left.error() == right.error() && left.detail() == right.detail();
}
inline bool operator!=(const ActionResult &left, const ActionResult &right) Q_DECL_NOTHROW {
    return !(left == right);
}

inline QDataStream &operator<<(QDataStream &ds, const ActionResult &obj) {
    QtRemoteObjects::copyStoredProperties(&obj, ds);
    return ds;
}

inline QDataStream &operator>>(QDataStream &ds, ActionResult &obj) {
    QtRemoteObjects::copyStoredProperties(ds, &obj);
    return ds;
}


class CameraPosition
{
    Q_GADGET

    Q_PROPERTY(QVector3D position READ position WRITE setPosition)
    Q_PROPERTY(QVector3D center READ center WRITE setCenter)
    Q_PROPERTY(QVector3D up READ up WRITE setUp)
    Q_PROPERTY(bool boundbox READ boundbox WRITE setBoundbox)
public:
    CameraPosition() : _position(), _center(), _up(), _boundbox() {}
    explicit CameraPosition(QVector3D position, QVector3D center, QVector3D up, bool boundbox) : _position(position), _center(center), _up(up), _boundbox(boundbox) {}
    QVector3D position() const { return _position; }
    void setPosition(QVector3D position) { if (position != _position) { _position = position; } }
    QVector3D center() const { return _center; }
    void setCenter(QVector3D center) { if (center != _center) { _center = center; } }
    QVector3D up() const { return _up; }
    void setUp(QVector3D up) { if (up != _up) { _up = up; } }
    bool boundbox() const { return _boundbox; }
    void setBoundbox(bool boundbox) { if (boundbox != _boundbox) { _boundbox = boundbox; } }
private:
    QVector3D _position;
    QVector3D _center;
    QVector3D _up;
    bool _boundbox;
};

inline bool operator==(const CameraPosition &left, const CameraPosition &right) Q_DECL_NOTHROW {
    return left.position() == right.position() && left.center() == right.center() && left.up() == right.up() && left.boundbox() == right.boundbox();
}
inline bool operator!=(const CameraPosition &left, const CameraPosition &right) Q_DECL_NOTHROW {
    return !(left == right);
}

inline QDataStream &operator<<(QDataStream &ds, const CameraPosition &obj) {
    QtRemoteObjects::copyStoredProperties(&obj, ds);
    return ds;
}

inline QDataStream &operator>>(QDataStream &ds, CameraPosition &obj) {
    QtRemoteObjects::copyStoredProperties(ds, &obj);
    return ds;
}


class PointCloudMemoryHeader
{
    Q_GADGET

    Q_PROPERTY(bool isOpen READ isOpen WRITE setIsOpen)
    Q_PROPERTY(QString name READ name WRITE setName)
    Q_PROPERTY(int alignIndex READ alignIndex WRITE setAlignIndex)
    Q_PROPERTY(QString groupName READ groupName WRITE setGroupName)
    Q_PROPERTY(int pointCount READ pointCount WRITE setPointCount)
    Q_PROPERTY(bool hasTexture READ hasTexture WRITE setHasTexture)
    Q_PROPERTY(bool hasNormal READ hasNormal WRITE setHasNormal)
    Q_PROPERTY(bool incremental READ incremental WRITE setIncremental)
    Q_PROPERTY(bool hasMarkers READ hasMarkers WRITE setHasMarkers)
    Q_PROPERTY(int markerCount READ markerCount WRITE setMarkerCount)
    Q_PROPERTY(bool haveUsed READ haveUsed WRITE setHaveUsed)
    Q_PROPERTY(bool hasTexurePicture READ hasTexurePicture WRITE setHasTexurePicture)
    Q_PROPERTY(int faceCount READ faceCount WRITE setFaceCount)
    Q_PROPERTY(int textureImgWidth READ textureImgWidth WRITE setTextureImgWidth)
    Q_PROPERTY(int textureImgHeight READ textureImgHeight WRITE setTextureImgHeight)
    Q_PROPERTY(int textureUVCount READ textureUVCount WRITE setTextureUVCount)
    Q_PROPERTY(bool hasFaceNormal READ hasFaceNormal WRITE setHasFaceNormal)
    Q_PROPERTY(int packId READ packId WRITE setPackId)
    Q_PROPERTY(int totalPacks READ totalPacks WRITE setTotalPacks)
    Q_PROPERTY(int dataSize READ dataSize WRITE setDataSize)
public:
    PointCloudMemoryHeader() : _isOpen(), _name(), _alignIndex(), _groupName(), _pointCount(), _hasTexture(), _hasNormal(), _incremental(), _hasMarkers(), _markerCount(), _haveUsed(), _hasTexurePicture(), _faceCount(), _textureImgWidth(), _textureImgHeight(), _textureUVCount(), _hasFaceNormal(), _packId(), _totalPacks(), _dataSize() {}
    explicit PointCloudMemoryHeader(bool isOpen, QString name, int alignIndex, QString groupName, int pointCount, bool hasTexture, bool hasNormal, bool incremental, bool hasMarkers, int markerCount, bool haveUsed, bool hasTexurePicture, int faceCount, int textureImgWidth, int textureImgHeight, int textureUVCount, bool hasFaceNormal, int packId, int totalPacks, int dataSize) : _isOpen(isOpen), _name(name), _alignIndex(alignIndex), _groupName(groupName), _pointCount(pointCount), _hasTexture(hasTexture), _hasNormal(hasNormal), _incremental(incremental), _hasMarkers(hasMarkers), _markerCount(markerCount), _haveUsed(haveUsed), _hasTexurePicture(hasTexurePicture), _faceCount(faceCount), _textureImgWidth(textureImgWidth), _textureImgHeight(textureImgHeight), _textureUVCount(textureUVCount), _hasFaceNormal(hasFaceNormal), _packId(packId), _totalPacks(totalPacks), _dataSize(dataSize) {}
    bool isOpen() const { return _isOpen; }
    void setIsOpen(bool isOpen) { if (isOpen != _isOpen) { _isOpen = isOpen; } }
    QString name() const { return _name; }
    void setName(QString name) { if (name != _name) { _name = name; } }
    int alignIndex() const { return _alignIndex; }
    void setAlignIndex(int alignIndex) { if (alignIndex != _alignIndex) { _alignIndex = alignIndex; } }
    QString groupName() const { return _groupName; }
    void setGroupName(QString groupName) { if (groupName != _groupName) { _groupName = groupName; } }
    int pointCount() const { return _pointCount; }
    void setPointCount(int pointCount) { if (pointCount != _pointCount) { _pointCount = pointCount; } }
    bool hasTexture() const { return _hasTexture; }
    void setHasTexture(bool hasTexture) { if (hasTexture != _hasTexture) { _hasTexture = hasTexture; } }
    bool hasNormal() const { return _hasNormal; }
    void setHasNormal(bool hasNormal) { if (hasNormal != _hasNormal) { _hasNormal = hasNormal; } }
    bool incremental() const { return _incremental; }
    void setIncremental(bool incremental) { if (incremental != _incremental) { _incremental = incremental; } }
    bool hasMarkers() const { return _hasMarkers; }
    void setHasMarkers(bool hasMarkers) { if (hasMarkers != _hasMarkers) { _hasMarkers = hasMarkers; } }
    int markerCount() const { return _markerCount; }
    void setMarkerCount(int markerCount) { if (markerCount != _markerCount) { _markerCount = markerCount; } }
    bool haveUsed() const { return _haveUsed; }
    void setHaveUsed(bool haveUsed) { if (haveUsed != _haveUsed) { _haveUsed = haveUsed; } }
    bool hasTexurePicture() const { return _hasTexurePicture; }
    void setHasTexurePicture(bool hasTexurePicture) { if (hasTexurePicture != _hasTexurePicture) { _hasTexurePicture = hasTexurePicture; } }
    int faceCount() const { return _faceCount; }
    void setFaceCount(int faceCount) { if (faceCount != _faceCount) { _faceCount = faceCount; } }
    int textureImgWidth() const { return _textureImgWidth; }
    void setTextureImgWidth(int textureImgWidth) { if (textureImgWidth != _textureImgWidth) { _textureImgWidth = textureImgWidth; } }
    int textureImgHeight() const { return _textureImgHeight; }
    void setTextureImgHeight(int textureImgHeight) { if (textureImgHeight != _textureImgHeight) { _textureImgHeight = textureImgHeight; } }
    int textureUVCount() const { return _textureUVCount; }
    void setTextureUVCount(int textureUVCount) { if (textureUVCount != _textureUVCount) { _textureUVCount = textureUVCount; } }
    bool hasFaceNormal() const { return _hasFaceNormal; }
    void setHasFaceNormal(bool hasFaceNormal) { if (hasFaceNormal != _hasFaceNormal) { _hasFaceNormal = hasFaceNormal; } }
    int packId() const { return _packId; }
    void setPackId(int packId) { if (packId != _packId) { _packId = packId; } }
    int totalPacks() const { return _totalPacks; }
    void setTotalPacks(int totalPacks) { if (totalPacks != _totalPacks) { _totalPacks = totalPacks; } }
    int dataSize() const { return _dataSize; }
    void setDataSize(int dataSize) { if (dataSize != _dataSize) { _dataSize = dataSize; } }
private:
    bool _isOpen;
    QString _name;
    int _alignIndex;
    QString _groupName;
    int _pointCount;
    bool _hasTexture;
    bool _hasNormal;
    bool _incremental;
    bool _hasMarkers;
    int _markerCount;
    bool _haveUsed;
    bool _hasTexurePicture;
    int _faceCount;
    int _textureImgWidth;
    int _textureImgHeight;
    int _textureUVCount;
    bool _hasFaceNormal;
    int _packId;
    int _totalPacks;
    int _dataSize;
};

inline bool operator==(const PointCloudMemoryHeader &left, const PointCloudMemoryHeader &right) Q_DECL_NOTHROW {
    return left.isOpen() == right.isOpen() && left.name() == right.name() && left.alignIndex() == right.alignIndex() && left.groupName() == right.groupName() && left.pointCount() == right.pointCount() && left.hasTexture() == right.hasTexture() && left.hasNormal() == right.hasNormal() && left.incremental() == right.incremental() && left.hasMarkers() == right.hasMarkers() && left.markerCount() == right.markerCount() && left.haveUsed() == right.haveUsed() && left.hasTexurePicture() == right.hasTexurePicture() && left.faceCount() == right.faceCount() && left.textureImgWidth() == right.textureImgWidth() && left.textureImgHeight() == right.textureImgHeight() && left.textureUVCount() == right.textureUVCount() && left.hasFaceNormal() == right.hasFaceNormal() && left.packId() == right.packId() && left.totalPacks() == right.totalPacks() && left.dataSize() == right.dataSize();
}
inline bool operator!=(const PointCloudMemoryHeader &left, const PointCloudMemoryHeader &right) Q_DECL_NOTHROW {
    return !(left == right);
}

inline QDataStream &operator<<(QDataStream &ds, const PointCloudMemoryHeader &obj) {
    QtRemoteObjects::copyStoredProperties(&obj, ds);
    return ds;
}

inline QDataStream &operator>>(QDataStream &ds, PointCloudMemoryHeader &obj) {
    QtRemoteObjects::copyStoredProperties(ds, &obj);
    return ds;
}


class VideoDataMemoryHeader
{
    Q_GADGET

    Q_PROPERTY(int camId READ camId WRITE setCamId)
    Q_PROPERTY(int width READ width WRITE setWidth)
    Q_PROPERTY(int height READ height WRITE setHeight)
    Q_PROPERTY(int channel READ channel WRITE setChannel)
    Q_PROPERTY(int dataChanged READ dataChanged WRITE setDataChanged)
public:
    VideoDataMemoryHeader() : _camId(), _width(), _height(), _channel(), _dataChanged() {}
    explicit VideoDataMemoryHeader(int camId, int width, int height, int channel, int dataChanged) : _camId(camId), _width(width), _height(height), _channel(channel), _dataChanged(dataChanged) {}
    int camId() const { return _camId; }
    void setCamId(int camId) { if (camId != _camId) { _camId = camId; } }
    int width() const { return _width; }
    void setWidth(int width) { if (width != _width) { _width = width; } }
    int height() const { return _height; }
    void setHeight(int height) { if (height != _height) { _height = height; } }
    int channel() const { return _channel; }
    void setChannel(int channel) { if (channel != _channel) { _channel = channel; } }
    int dataChanged() const { return _dataChanged; }
    void setDataChanged(int dataChanged) { if (dataChanged != _dataChanged) { _dataChanged = dataChanged; } }
private:
    int _camId;
    int _width;
    int _height;
    int _channel;
    int _dataChanged;
};

inline bool operator==(const VideoDataMemoryHeader &left, const VideoDataMemoryHeader &right) Q_DECL_NOTHROW {
    return left.camId() == right.camId() && left.width() == right.width() && left.height() == right.height() && left.channel() == right.channel() && left.dataChanged() == right.dataChanged();
}
inline bool operator!=(const VideoDataMemoryHeader &left, const VideoDataMemoryHeader &right) Q_DECL_NOTHROW {
    return !(left == right);
}

inline QDataStream &operator<<(QDataStream &ds, const VideoDataMemoryHeader &obj) {
    QtRemoteObjects::copyStoredProperties(&obj, ds);
    return ds;
}

inline QDataStream &operator>>(QDataStream &ds, VideoDataMemoryHeader &obj) {
    QtRemoteObjects::copyStoredProperties(ds, &obj);
    return ds;
}


class DeletePointsMemoryHeader
{
    Q_GADGET

    Q_PROPERTY(QStringList names READ names WRITE setNames)
    Q_PROPERTY(QVector<int> ids READ ids WRITE setIds)
    Q_PROPERTY(QVector<int> counts READ counts WRITE setCounts)
    Q_PROPERTY(int totalPacket READ totalPacket WRITE setTotalPacket)
    Q_PROPERTY(int packId READ packId WRITE setPackId)
    Q_PROPERTY(int dataCount READ dataCount WRITE setDataCount)
public:
    DeletePointsMemoryHeader() : _names(), _ids(), _counts(), _totalPacket(), _packId(), _dataCount() {}
    explicit DeletePointsMemoryHeader(QStringList names, QVector<int> ids, QVector<int> counts, int totalPacket, int packId, int dataCount) : _names(names), _ids(ids), _counts(counts), _totalPacket(totalPacket), _packId(packId), _dataCount(dataCount) {}
    QStringList names() const { return _names; }
    void setNames(QStringList names) { if (names != _names) { _names = names; } }
    QVector<int> ids() const { return _ids; }
    void setIds(QVector<int> ids) { if (ids != _ids) { _ids = ids; } }
    QVector<int> counts() const { return _counts; }
    void setCounts(QVector<int> counts) { if (counts != _counts) { _counts = counts; } }
    int totalPacket() const { return _totalPacket; }
    void setTotalPacket(int totalPacket) { if (totalPacket != _totalPacket) { _totalPacket = totalPacket; } }
    int packId() const { return _packId; }
    void setPackId(int packId) { if (packId != _packId) { _packId = packId; } }
    int dataCount() const { return _dataCount; }
    void setDataCount(int dataCount) { if (dataCount != _dataCount) { _dataCount = dataCount; } }
private:
    QStringList _names;
    QVector<int> _ids;
    QVector<int> _counts;
    int _totalPacket;
    int _packId;
    int _dataCount;
};

inline bool operator==(const DeletePointsMemoryHeader &left, const DeletePointsMemoryHeader &right) Q_DECL_NOTHROW {
    return left.names() == right.names() && left.ids() == right.ids() && left.counts() == right.counts() && left.totalPacket() == right.totalPacket() && left.packId() == right.packId() && left.dataCount() == right.dataCount();
}
inline bool operator!=(const DeletePointsMemoryHeader &left, const DeletePointsMemoryHeader &right) Q_DECL_NOTHROW {
    return !(left == right);
}

inline QDataStream &operator<<(QDataStream &ds, const DeletePointsMemoryHeader &obj) {
    QtRemoteObjects::copyStoredProperties(&obj, ds);
    return ds;
}

inline QDataStream &operator>>(QDataStream &ds, DeletePointsMemoryHeader &obj) {
    QtRemoteObjects::copyStoredProperties(ds, &obj);
    return ds;
}


class NewProjectParams
{
    Q_GADGET

    Q_PROPERTY(QString globalMarkerFilePath READ globalMarkerFilePath WRITE setGlobalMarkerFilePath)
    Q_PROPERTY(bool textureEnabled READ textureEnabled WRITE setTextureEnabled)
    Q_PROPERTY(float pointDist READ pointDist WRITE setPointDist)
    Q_PROPERTY(int alignType READ alignType WRITE setAlignType)
    Q_PROPERTY(bool rapidMode READ rapidMode WRITE setRapidMode)
    Q_PROPERTY(bool fastSave READ fastSave WRITE setFastSave)
    Q_PROPERTY(bool flagAfterSolution READ flagAfterSolution WRITE setFlagAfterSolution)
public:
    NewProjectParams() : _globalMarkerFilePath(), _textureEnabled(), _pointDist(), _alignType(), _rapidMode(), _fastSave(), _flagAfterSolution() {}
    explicit NewProjectParams(QString globalMarkerFilePath, bool textureEnabled, float pointDist, int alignType, bool rapidMode, bool fastSave, bool flagAfterSolution) : _globalMarkerFilePath(globalMarkerFilePath), _textureEnabled(textureEnabled), _pointDist(pointDist), _alignType(alignType), _rapidMode(rapidMode), _fastSave(fastSave), _flagAfterSolution(flagAfterSolution) {}
    QString globalMarkerFilePath() const { return _globalMarkerFilePath; }
    void setGlobalMarkerFilePath(QString globalMarkerFilePath) { if (globalMarkerFilePath != _globalMarkerFilePath) { _globalMarkerFilePath = globalMarkerFilePath; } }
    bool textureEnabled() const { return _textureEnabled; }
    void setTextureEnabled(bool textureEnabled) { if (textureEnabled != _textureEnabled) { _textureEnabled = textureEnabled; } }
    float pointDist() const { return _pointDist; }
    void setPointDist(float pointDist) { if (pointDist != _pointDist) { _pointDist = pointDist; } }
    int alignType() const { return _alignType; }
    void setAlignType(int alignType) { if (alignType != _alignType) { _alignType = alignType; } }
    bool rapidMode() const { return _rapidMode; }
    void setRapidMode(bool rapidMode) { if (rapidMode != _rapidMode) { _rapidMode = rapidMode; } }
    bool fastSave() const { return _fastSave; }
    void setFastSave(bool fastSave) { if (fastSave != _fastSave) { _fastSave = fastSave; } }
    bool flagAfterSolution() const { return _flagAfterSolution; }
    void setFlagAfterSolution(bool flagAfterSolution) { if (flagAfterSolution != _flagAfterSolution) { _flagAfterSolution = flagAfterSolution; } }
private:
    QString _globalMarkerFilePath;
    bool _textureEnabled;
    float _pointDist;
    int _alignType;
    bool _rapidMode;
    bool _fastSave;
    bool _flagAfterSolution;
};

inline bool operator==(const NewProjectParams &left, const NewProjectParams &right) Q_DECL_NOTHROW {
    return left.globalMarkerFilePath() == right.globalMarkerFilePath() && left.textureEnabled() == right.textureEnabled() && left.pointDist() == right.pointDist() && left.alignType() == right.alignType() && left.rapidMode() == right.rapidMode() && left.fastSave() == right.fastSave() && left.flagAfterSolution() == right.flagAfterSolution();
}
inline bool operator!=(const NewProjectParams &left, const NewProjectParams &right) Q_DECL_NOTHROW {
    return !(left == right);
}

inline QDataStream &operator<<(QDataStream &ds, const NewProjectParams &obj) {
    QtRemoteObjects::copyStoredProperties(&obj, ds);
    return ds;
}

inline QDataStream &operator>>(QDataStream &ds, NewProjectParams &obj) {
    QtRemoteObjects::copyStoredProperties(ds, &obj);
    return ds;
}


class ScanParams
{
    Q_GADGET

    Q_PROPERTY(bool enableHDR READ enableHDR WRITE setEnableHDR)
    Q_PROPERTY(int alignType READ alignType WRITE setAlignType)
    Q_PROPERTY(int scanSubType READ scanSubType WRITE setScanSubType)
    Q_PROPERTY(int turntableTimes READ turntableTimes WRITE setTurntableTimes)
public:
    ScanParams() : _enableHDR(), _alignType(), _scanSubType(), _turntableTimes() {}
    explicit ScanParams(bool enableHDR, int alignType, int scanSubType, int turntableTimes) : _enableHDR(enableHDR), _alignType(alignType), _scanSubType(scanSubType), _turntableTimes(turntableTimes) {}
    bool enableHDR() const { return _enableHDR; }
    void setEnableHDR(bool enableHDR) { if (enableHDR != _enableHDR) { _enableHDR = enableHDR; } }
    int alignType() const { return _alignType; }
    void setAlignType(int alignType) { if (alignType != _alignType) { _alignType = alignType; } }
    int scanSubType() const { return _scanSubType; }
    void setScanSubType(int scanSubType) { if (scanSubType != _scanSubType) { _scanSubType = scanSubType; } }
    int turntableTimes() const { return _turntableTimes; }
    void setTurntableTimes(int turntableTimes) { if (turntableTimes != _turntableTimes) { _turntableTimes = turntableTimes; } }
private:
    bool _enableHDR;
    int _alignType;
    int _scanSubType;
    int _turntableTimes;
};

inline bool operator==(const ScanParams &left, const ScanParams &right) Q_DECL_NOTHROW {
    return left.enableHDR() == right.enableHDR() && left.alignType() == right.alignType() && left.scanSubType() == right.scanSubType() && left.turntableTimes() == right.turntableTimes();
}
inline bool operator!=(const ScanParams &left, const ScanParams &right) Q_DECL_NOTHROW {
    return !(left == right);
}

inline QDataStream &operator<<(QDataStream &ds, const ScanParams &obj) {
    QtRemoteObjects::copyStoredProperties(&obj, ds);
    return ds;
}

inline QDataStream &operator>>(QDataStream &ds, ScanParams &obj) {
    QtRemoteObjects::copyStoredProperties(ds, &obj);
    return ds;
}


class TriMesh
{
    Q_GADGET

    Q_PROPERTY(int id READ id WRITE setId)
    Q_PROPERTY(QVector<QVector3D> point READ point WRITE setPoint)
    Q_PROPERTY(QVector<QVector3D> normal READ normal WRITE setNormal)
public:
    TriMesh() : _id(), _point(), _normal() {}
    explicit TriMesh(int id, QVector<QVector3D> point, QVector<QVector3D> normal) : _id(id), _point(point), _normal(normal) {}
    int id() const { return _id; }
    void setId(int id) { if (id != _id) { _id = id; } }
    QVector<QVector3D> point() const { return _point; }
    void setPoint(QVector<QVector3D> point) { if (point != _point) { _point = point; } }
    QVector<QVector3D> normal() const { return _normal; }
    void setNormal(QVector<QVector3D> normal) { if (normal != _normal) { _normal = normal; } }
private:
    int _id;
    QVector<QVector3D> _point;
    QVector<QVector3D> _normal;
};

inline bool operator==(const TriMesh &left, const TriMesh &right) Q_DECL_NOTHROW {
    return left.id() == right.id() && left.point() == right.point() && left.normal() == right.normal();
}
inline bool operator!=(const TriMesh &left, const TriMesh &right) Q_DECL_NOTHROW {
    return !(left == right);
}

inline QDataStream &operator<<(QDataStream &ds, const TriMesh &obj) {
    QtRemoteObjects::copyStoredProperties(&obj, ds);
    return ds;
}

inline QDataStream &operator>>(QDataStream &ds, TriMesh &obj) {
    QtRemoteObjects::copyStoredProperties(ds, &obj);
    return ds;
}


class HoleLine
{
    Q_GADGET

    Q_PROPERTY(int id READ id WRITE setId)
    Q_PROPERTY(QVector<QVector3D> position READ position WRITE setPosition)
public:
    HoleLine() : _id(), _position() {}
    explicit HoleLine(int id, QVector<QVector3D> position) : _id(id), _position(position) {}
    int id() const { return _id; }
    void setId(int id) { if (id != _id) { _id = id; } }
    QVector<QVector3D> position() const { return _position; }
    void setPosition(QVector<QVector3D> position) { if (position != _position) { _position = position; } }
private:
    int _id;
    QVector<QVector3D> _position;
};

inline bool operator==(const HoleLine &left, const HoleLine &right) Q_DECL_NOTHROW {
    return left.id() == right.id() && left.position() == right.position();
}
inline bool operator!=(const HoleLine &left, const HoleLine &right) Q_DECL_NOTHROW {
    return !(left == right);
}

inline QDataStream &operator<<(QDataStream &ds, const HoleLine &obj) {
    QtRemoteObjects::copyStoredProperties(&obj, ds);
    return ds;
}

inline QDataStream &operator>>(QDataStream &ds, HoleLine &obj) {
    QtRemoteObjects::copyStoredProperties(ds, &obj);
    return ds;
}


class ScanServiceReplica : public QRemoteObjectReplica
{
    Q_OBJECT
    Q_CLASSINFO(QCLASSINFO_REMOTEOBJECT_TYPE, "ScanService")
    Q_CLASSINFO(QCLASSINFO_REMOTEOBJECT_SIGNATURE, "458ec97abdb237025afc5093024707954c15d3d6")
    Q_PROPERTY(int deviceBatch READ deviceBatch NOTIFY deviceBatchChanged)
    Q_PROPERTY(bool deviceWithoutTextureCamera READ deviceWithoutTextureCamera NOTIFY deviceWithoutTextureCameraChanged)
    Q_PROPERTY(QString deviceEdition READ deviceEdition NOTIFY deviceEditionChanged)
    Q_PROPERTY(int moveTooFast READ moveTooFast NOTIFY moveTooFastChanged)
    Q_PROPERTY(int motiondetect READ motiondetect WRITE setMotiondetect NOTIFY motiondetectChanged)
    Q_PROPERTY(int authSurplusDay READ authSurplusDay WRITE setAuthSurplusDay NOTIFY authSurplusDayChanged)
    Q_PROPERTY(bool showOverdueDialog READ showOverdueDialog WRITE setShowOverdueDialog NOTIFY showOverdueDialogChanged)
    Q_PROPERTY(int pleErrorType READ pleErrorType WRITE setPleErrorType NOTIFY pleErrorTypeChanged)
    Q_PROPERTY(QString contactEMail READ contactEMail NOTIFY contactEMailChanged)
    Q_PROPERTY(DeviceType deviceType READ deviceType NOTIFY deviceTypeChanged)
    Q_PROPERTY(DeviceSeries deviceSeries READ deviceSeries NOTIFY deviceSeriesChanged)
    Q_PROPERTY(DeviceSubType deviceSubType READ deviceSubType WRITE setDeviceSubType NOTIFY deviceSubTypeChanged)
    Q_PROPERTY(bool showHidePrimeVideo READ showHidePrimeVideo WRITE setShowHidePrimeVideo NOTIFY showHidePrimeVideoChanged)
    Q_PROPERTY(int language READ language WRITE setLanguage NOTIFY languageChanged)
    Q_PROPERTY(bool x2Plus READ x2Plus NOTIFY x2PlusChanged)
    Q_PROPERTY(DeviceStatus deviceStatus READ deviceStatus WRITE setDeviceStatus NOTIFY deviceStatusChanged)
    Q_PROPERTY(QVariantMap caliInfo READ caliInfo NOTIFY caliInfoChanged)
    Q_PROPERTY(bool hasIr READ hasIr NOTIFY hasIrChanged)
    Q_PROPERTY(bool hasColor READ hasColor NOTIFY hasColorChanged)
    Q_PROPERTY(bool isNeedShowColorGama READ isNeedShowColorGama NOTIFY isNeedShowColorGamaChanged)
    Q_PROPERTY(bool isFirmwareVersionTextureAlignEnable READ isFirmwareVersionTextureAlignEnable NOTIFY isFirmwareVersionTextureAlignEnableChanged)
    Q_PROPERTY(bool hasDiscovery READ hasDiscovery NOTIFY hasDiscoveryChanged)
    Q_PROPERTY(bool globalmarkerScan READ globalmarkerScan NOTIFY globalmarkerScanChanged)
    Q_PROPERTY(bool firmwareUpgradable READ firmwareUpgradable NOTIFY firmwareUpgradableChanged)
    Q_PROPERTY(int currentBrightness READ currentBrightness WRITE setCurrentBrightness NOTIFY currentBrightnessChanged)
    Q_PROPERTY(int currentLaserQualityStep READ currentLaserQualityStep WRITE setCurrentLaserQualityStep NOTIFY currentLaserQualityStepChanged)
    Q_PROPERTY(int currentLaserBrightness READ currentLaserBrightness WRITE setCurrentLaserBrightness NOTIFY currentLaserBrightnessChanged)
    Q_PROPERTY(int currentLEDDutyCycle READ currentLEDDutyCycle WRITE setCurrentLEDDutyCycle NOTIFY currentLEDDutyCycleChanged)
    Q_PROPERTY(bool isLedOpen READ isLedOpen WRITE setIsLedOpen NOTIFY isLedOpenChanged)
    Q_PROPERTY(bool isPlaneDetectOpen READ isPlaneDetectOpen WRITE setIsPlaneDetectOpen NOTIFY isPlaneDetectOpenChanged)
    Q_PROPERTY(ModelColorType modelColor READ modelColor WRITE setModelColor NOTIFY modelColorChanged)
    Q_PROPERTY(ScanObjType scanObj READ scanObj WRITE setScanObj NOTIFY scanObjChanged)
    Q_PROPERTY(LaserScanType laserScanType READ laserScanType WRITE setLaserScanType NOTIFY laserScanTypeChanged)
    Q_PROPERTY(int e3MainBrightnessCtrl READ e3MainBrightnessCtrl WRITE setE3MainBrightnessCtrl NOTIFY e3MainBrightnessCtrlChanged)
    Q_PROPERTY(ScanObjInPortraitModeType scanObjInPortraitModeType READ scanObjInPortraitModeType WRITE setScanObjInPortraitModeType NOTIFY scanObjInPortraitModeTypeChanged)
    Q_PROPERTY(bool dataOptimiaztion READ dataOptimiaztion NOTIFY dataOptimiaztionChanged)
    Q_PROPERTY(QVariantList brightnessRange READ brightnessRange NOTIFY brightnessRangeChanged)
    Q_PROPERTY(QVariantList laserQualityStepRange READ laserQualityStepRange NOTIFY laserQualityStepRangeChanged)
    Q_PROPERTY(int frameCount READ frameCount WRITE setFrameCount NOTIFY frameCountChanged)
    Q_PROPERTY(int exprotFramerMarkerCount READ exprotFramerMarkerCount WRITE setExprotFramerMarkerCount NOTIFY exprotFramerMarkerCountChanged)
    Q_PROPERTY(int currentProjectMarkerCount READ currentProjectMarkerCount WRITE setCurrentProjectMarkerCount NOTIFY currentProjectMarkerCountChanged)
    Q_PROPERTY(bool framerMarkHasNormal READ framerMarkHasNormal WRITE setFramerMarkHasNormal NOTIFY framerMarkHasNormalChanged)
    Q_PROPERTY(int pointCount READ pointCount WRITE setPointCount NOTIFY pointCountChanged)
    Q_PROPERTY(int pointFaceCount READ pointFaceCount WRITE setPointFaceCount NOTIFY pointFaceCountChanged)
    Q_PROPERTY(int meshPointCount READ meshPointCount WRITE setMeshPointCount NOTIFY meshPointCountChanged)
    Q_PROPERTY(int framerate READ framerate NOTIFY framerateChanged)
    Q_PROPERTY(int triangleCount READ triangleCount WRITE setTriangleCount NOTIFY triangleCountChanged)
    Q_PROPERTY(int markerCount READ markerCount NOTIFY markerCountChanged)
    Q_PROPERTY(QVariantList frameMemory READ frameMemory NOTIFY frameMemoryChanged)
    Q_PROPERTY(CameraPosition cameraPosition READ cameraPosition NOTIFY cameraPositionChanged)
    Q_PROPERTY(ScanType scanType READ scanType WRITE setScanType NOTIFY scanTypeChanged)
    Q_PROPERTY(SubScanType subScanType READ subScanType WRITE setSubScanType NOTIFY subScanTypeChanged)
    Q_PROPERTY(int handleScanAlignType READ handleScanAlignType NOTIFY handleScanAlignTypeChanged)
    Q_PROPERTY(QString lastProjectSavePath READ lastProjectSavePath NOTIFY lastProjectSavePathChanged)
    Q_PROPERTY(bool hasMeshData READ hasMeshData NOTIFY hasMeshDataChanged)
    Q_PROPERTY(bool isHDR READ isHDR NOTIFY isHDRChanged)
    Q_PROPERTY(bool useDiscovery READ useDiscovery NOTIFY useDiscoveryChanged)
    Q_PROPERTY(bool hasLightBox READ hasLightBox NOTIFY hasLightBoxChanged)
    Q_PROPERTY(bool lightBoxOpen READ lightBoxOpen NOTIFY lightBoxOpenChanged)
    Q_PROPERTY(bool hasTurntable READ hasTurntable NOTIFY hasTurntableChanged)
    Q_PROPERTY(bool scanWithTexture READ scanWithTexture WRITE setScanWithTexture NOTIFY scanWithTextureChanged)
    Q_PROPERTY(int solutionWithTexture READ solutionWithTexture WRITE setSolutionWithTexture NOTIFY solutionWithTextureChanged)
    Q_PROPERTY(QVariantList pointDistRange READ pointDistRange NOTIFY pointDistRangeChanged)
    Q_PROPERTY(QVariantList resolutionValue READ resolutionValue NOTIFY resolutionValueChanged)
    Q_PROPERTY(float currentPointDist READ currentPointDist WRITE setCurrentPointDist NOTIFY currentPointDistChanged)
    Q_PROPERTY(bool microspurPointDist READ microspurPointDist WRITE setMicrospurPointDist NOTIFY microspurPointDistChanged)
    Q_PROPERTY(double currentPointDistStep READ currentPointDistStep WRITE setCurrentPointDistStep NOTIFY currentPointDistStepChanged)
    Q_PROPERTY(QString currentPle READ currentPle NOTIFY currentPleChanged)
    Q_PROPERTY(bool snapEnabled READ snapEnabled WRITE setSnapEnabled NOTIFY snapEnabledChanged)
    Q_PROPERTY(CaliType caliType READ caliType WRITE setCaliType NOTIFY caliTypeChanged)
    Q_PROPERTY(bool isCalibGuidePageVisible READ isCalibGuidePageVisible WRITE setIsCalibGuidePageVisible NOTIFY isCalibGuidePageVisibleChanged)
    Q_PROPERTY(int currentCaliGroup READ currentCaliGroup WRITE setCurrentCaliGroup NOTIFY currentCaliGroupChanged)
    Q_PROPERTY(int currentCaliDist READ currentCaliDist NOTIFY currentCaliDistChanged)
    Q_PROPERTY(QVariantMap postProcessParam READ postProcessParam NOTIFY postProcessParamChanged)
    Q_PROPERTY(QVector<bool> caliDistStates READ caliDistStates NOTIFY caliDistStatesChanged)
    Q_PROPERTY(ScanStatus scanStatus READ scanStatus NOTIFY scanStatusChanged)
    Q_PROPERTY(int scanDist READ scanDist NOTIFY scanDistChanged)
    Q_PROPERTY(bool rapidMode READ rapidMode NOTIFY rapidModeChanged)
    Q_PROPERTY(bool rapidSave READ rapidSave NOTIFY rapidSaveChanged)
    Q_PROPERTY(bool noMarkerDetected READ noMarkerDetected NOTIFY noMarkerDetectedChanged)
    Q_PROPERTY(bool tooFlat READ tooFlat NOTIFY tooFlatChanged)
    Q_PROPERTY(bool trackLost READ trackLost NOTIFY trackLostChanged)
    Q_PROPERTY(bool updateFirm READ updateFirm WRITE setUpdateFirm NOTIFY updateFirmChanged)
    Q_PROPERTY(bool showCalibVideo READ showCalibVideo NOTIFY showCalibVideoChanged)
    Q_PROPERTY(int progress READ progress NOTIFY progressChanged)
    Q_PROPERTY(MeshType lastMeshType READ lastMeshType NOTIFY lastMeshTypeChanged)
    Q_PROPERTY(int lastMeshDetail READ lastMeshDetail NOTIFY lastMeshDetailChanged)
    Q_PROPERTY(int minRemainMemory READ minRemainMemory NOTIFY minRemainMemoryChanged)
    Q_PROPERTY(int minRemainDisk READ minRemainDisk NOTIFY minRemainDiskChanged)
    Q_PROPERTY(QString currentProjectPath READ currentProjectPath NOTIFY currentProjectPathChanged)
    Q_PROPERTY(int currentTurntableSteps READ currentTurntableSteps WRITE setCurrentTurntableSteps NOTIFY currentTurntableStepsChanged)
    Q_PROPERTY(bool isTextureAlignEnable READ isTextureAlignEnable WRITE setIsTextureAlignEnable NOTIFY isTextureAlignEnableChanged)
    Q_PROPERTY(bool isCurrentProjectHasMarker READ isCurrentProjectHasMarker NOTIFY isCurrentProjectHasMarkerChanged)
    Q_PROPERTY(QVariantMap lastSimpleParams READ lastSimpleParams NOTIFY lastSimpleParamsChanged)
    Q_PROPERTY(QVariantMap lastSaveResizeParams READ lastSaveResizeParams NOTIFY lastSaveResizeParamsChanged)
    Q_PROPERTY(bool isInternal READ isInternal NOTIFY isInternalChanged)
    Q_PROPERTY(bool isRightPrivateDebugFile READ isRightPrivateDebugFile NOTIFY isRightPrivateDebugFileChanged)
    Q_PROPERTY(QString currentSlnPath READ currentSlnPath NOTIFY currentSlnPathChanged)
    Q_PROPERTY(int globalOptimization READ globalOptimization NOTIFY globalOptimizationChanged)
    Q_PROPERTY(bool meshDataHasMarker READ meshDataHasMarker NOTIFY meshDataHasMarkerChanged)
    Q_PROPERTY(bool isMeshDataWarterTight READ isMeshDataWarterTight NOTIFY isMeshDataWarterTightChanged)
    Q_PROPERTY(bool isBigWorkRange READ isBigWorkRange WRITE setIsBigWorkRange NOTIFY isBigWorkRangeChanged)
    Q_PROPERTY(double currentSolutionPointDist READ currentSolutionPointDist WRITE setCurrentSolutionPointDist NOTIFY currentSolutionPointDistChanged)

public:
    enum ErrorCode {
        EC_NOERROR = 0,
        EC_PARAM_ERROR = 1,
        EC_ORDER_ERROR = 2,
        EC_TIME_OUT = 3,
        EC_NOT_SUPPORT = 4,
        EC_NO_DEVICE = 5,
        EC_DEVICE_LICENSE_ERROR = 6,
        EC_GPU_ERROR = 7,
        EC_INNER_ERROR = 8,
        EC_NOT_CALIBRATE = 9,
        EC_LOST_CONFIG_FILE = 10,
        EC_NO_DATAR = 11,
        EC_LOST_CALIBRATE_FILE = 12,
        EC_NO_GLOBAL_MARK_POINT_PARAM = 13,
    };
#if (QT_VERSION >= QT_VERSION_CHECK(5, 5, 0))
    Q_ENUM(ErrorCode)
#else
    Q_ENUMS(ErrorCode)
#endif
    enum DeviceType {
        DT_S = 1,
        DT_PRO = 2,
    };
#if (QT_VERSION >= QT_VERSION_CHECK(5, 5, 0))
    Q_ENUM(DeviceType)
#else
    Q_ENUMS(DeviceType)
#endif
    enum DeviceSeries {
        DEVICE_2X = 1,
        DEVICE_E7 = 2,
        DEVICE_E3 = 3,
        DEVICE_Ue = 4,
    };
#if (QT_VERSION >= QT_VERSION_CHECK(5, 5, 0))
    Q_ENUM(DeviceSeries)
#else
    Q_ENUMS(DeviceSeries)
#endif
    enum DeviceSubType {
        DST_PRO = 1,
        DST_PRO_PLUS = 2,
        DST_S_S10 = 3,
        DST_S20 = 5,
        DST_S2PLUS = 6,
        DST_E3_HX = 8,
        DST_E3_H = 9,
        DST_UE = 10,
    };
#if (QT_VERSION >= QT_VERSION_CHECK(5, 5, 0))
    Q_ENUM(DeviceSubType)
#else
    Q_ENUMS(DeviceSubType)
#endif
    enum DeviceStatus {
        DS_OFFLINE = 0,
        DS_ONLINE = 1,
    };
#if (QT_VERSION >= QT_VERSION_CHECK(5, 5, 0))
    Q_ENUM(DeviceStatus)
#else
    Q_ENUMS(DeviceStatus)
#endif
    enum DeviceEvent {
        DE_NULL = -1,
        DE_DOUBLECLICK = 0,
        DE_CLICK = 1,
        DE_PLUS = 2,
        DE_SUB = 3,
        DE_E3_DISTANCE_PLUS = 4,
        DE_E3_DISTANCE_SUB = 5,
        DE_E3_TAP_POSITION_PLUS = 6,
        DE_E3_TAP_POSITION_SUB = 7,
        DE_LONGPRESS = 8,
        DE_UE_CENTER_BTN_MEN = 9,
        DE_UE_LBTN_LONGPRESS = 10,
        DE_UE_RBTN_LONGPRESS = 11,
        DE_UE_UBTN_DCLICK = 12,
        DE_UE_UBTN_LONGPRESS = 13,
        DE_UE_DBTN_DCLICK = 14,
        DE_UE_DBTN_LONGPRESS = 15,
        DE_UE_BTN_DCLICK = 16,
    };
#if (QT_VERSION >= QT_VERSION_CHECK(5, 5, 0))
    Q_ENUM(DeviceEvent)
#else
    Q_ENUMS(DeviceEvent)
#endif
    enum ScanType {
        ST_FIXED = 0,
        ST_HD = 1,
        ST_RAPID = 2,
        ST_E3_HX_NORMAL = 3,
        ST_E3_HX_LASER = 4,
        ST_E3_H_NORMAL = 5,
        ST_E3_H_BODY = 6,
        ST_E3_H_PORTRAIT = 7,
        ST_E3_CALIB = 8,
        ST_UE_LASER = 10,
    };
#if (QT_VERSION >= QT_VERSION_CHECK(5, 5, 0))
    Q_ENUM(ScanType)
#else
    Q_ENUMS(ScanType)
#endif
    enum SubScanType {
        SST_FIXED_FREE = 0,
        SST_FIXED_TURNABLE = 1,
    };
#if (QT_VERSION >= QT_VERSION_CHECK(5, 5, 0))
    Q_ENUM(SubScanType)
#else
    Q_ENUMS(SubScanType)
#endif
    enum CaliType {
        CT_STEREO = 1,
        CT_HD = 2,
        CT_WHITE_BALANCE = 3,
        CT_DEFINITION = 4,
        CT_RAPID = 5,
        CT_LASER = 6,
    };
#if (QT_VERSION >= QT_VERSION_CHECK(5, 5, 0))
    Q_ENUM(CaliType)
#else
    Q_ENUMS(CaliType)
#endif
    enum AlignType {
        AT_FEATURES = 0,
        AT_MARKERS = 1,
        AT_HYBRID = 2,
        AT_AUTO = 4,
        AT_TURTABLE = 5,
        AT_CODE_POINT = 6,
        AT_GLOBAL_POINT = 7,
        AT_TEXTURE = 8,
    };
#if (QT_VERSION >= QT_VERSION_CHECK(5, 5, 0))
    Q_ENUM(AlignType)
#else
    Q_ENUMS(AlignType)
#endif
    enum ScanStatus {
        SS_PRE_SCAN = 1,
        SS_PRE_SCANNING = 2,
        SS_SCAN = 3,
        SS_PAUSED = 4,
        SS_SCAN_STOPED = 5,
    };
#if (QT_VERSION >= QT_VERSION_CHECK(5, 5, 0))
    Q_ENUM(ScanStatus)
#else
    Q_ENUMS(ScanStatus)
#endif
    enum MemoryType {
        MT_POINT_CLOUD = 0,
        MT_DELETE_POINTS = 1,
        MT_MARKERS = 2,
        MT_TRI_MESH = 3,
        MT_VIDEO_DATA = 4,
        MT_RANGE_DATA = 5,
        MT_HOLE_LINE = 6,
        MT_FILL_HOLE_MESH = 7,
        MT_MULTI_PROJECT_POINT_CLOUD = 8,
        MT_BODY_SCAN_POINT_CLOUD = 9,
        MT_GENERATE_POINT_CLOUD_EDIT = 10,
    };
#if (QT_VERSION >= QT_VERSION_CHECK(5, 5, 0))
    Q_ENUM(MemoryType)
#else
    Q_ENUMS(MemoryType)
#endif
    enum MeshType {
        MT_NON_WATERTIGHT = 0,
        MT_WATERTIGHT = 1,
    };
#if (QT_VERSION >= QT_VERSION_CHECK(5, 5, 0))
    Q_ENUM(MeshType)
#else
    Q_ENUMS(MeshType)
#endif
    enum ModelColorType {
        MCT_UNDEFINED = -1,
        MCT_BRIGHT = 0,
        MCT_DARK = 1,
        MCT_NORMAL = 2,
    };
#if (QT_VERSION >= QT_VERSION_CHECK(5, 5, 0))
    Q_ENUM(ModelColorType)
#else
    Q_ENUMS(ModelColorType)
#endif
    enum ScanObjType {
        SOT_UNDEFINED = -1,
        SOT_NORMAL = 0,
        SOT_DARK = 1,
        SOT_REFLECT = 2,
    };
#if (QT_VERSION >= QT_VERSION_CHECK(5, 5, 0))
    Q_ENUM(ScanObjType)
#else
    Q_ENUMS(ScanObjType)
#endif
    enum LaserScanType {
        LST_SINGLE_LINE = 0,
        LST_MUTI_LINE = 1,
    };
#if (QT_VERSION >= QT_VERSION_CHECK(5, 5, 0))
    Q_ENUM(LaserScanType)
#else
    Q_ENUMS(LaserScanType)
#endif
    enum ScanObjInPortraitModeType {
        SOPMT_HEAD = 0,
        SOPMT_BODY = 1,
    };
#if (QT_VERSION >= QT_VERSION_CHECK(5, 5, 0))
    Q_ENUM(ScanObjInPortraitModeType)
#else
    Q_ENUMS(ScanObjInPortraitModeType)
#endif
    enum ChangeEventType {
        CET_BRIGHTNESS = 0,
        CET_SCANOBJ = 1,
        CET_BRIGHTNESS_QUALITY = 2,
        CET_BRIGHTNESS_LASER = 3,
        CET_BRIGHTNESS_LED = 4,
    };
#if (QT_VERSION >= QT_VERSION_CHECK(5, 5, 0))
    Q_ENUM(ChangeEventType)
#else
    Q_ENUMS(ChangeEventType)
#endif
    enum AsyncActionType {
        AAT_CHECK_DEVICE = 0,
        AAT_ENTER_CALI = 1,
        AAT_CHANGE_CALI_TYPE = 2,
        AAT_EXIT_CALI = 3,
        AAT_COMPUTE_CALI = 4,
        AAT_NEW_PROJECT = 5,
        AAT_OPEN_PROJECT = 6,
        AAT_ENTER_SCAN = 7,
        AAT_EXIT_SCAN = 8,
        AAT_CANCEL_SCAN = 9,
        AAT_END_SCAN = 10,
        AAT_SCAN = 11,
        AAT_WHITE_BAL = 12,
        AAT_MANUAL_ALIGN = 13,
        AAT_MESH = 14,
        AAT_SIMPLIFY = 15,
        AAT_EDIT = 16,
        AAT_EDIT_LIST = 17,
        AAT_DEL_POINT_CLOUD = 18,
        AAT_SAVE = 19,
        AAT_FIX_SINGLE_EDIT = 20,
        AAT_AXIS_VERIFY = 21,
        AAT_FIX_SCAN = 22,
        AAT_FIX_REMOVE_DATA = 23,
        AAT_FIX_UPDATE_DATA_RT = 24,
        AAT_EXPORT_SHARE_DATA = 25,
        AAT_LOAD_MODEL = 26,
        AAT_ENTER_POSTDATAPROCESS = 27,
        AAT_EXIT_POSTDATAPROCESS = 28,
        AAT_ENTER_FILL_HOLE_MODE = 29,
        AAT_APPLAY_FILLHOLE = 30,
        AAT_FILLING_HOLE = 31,
        AAT_SMOOTH = 32,
        AAT_SHARP = 33,
        AAT_ZOOM = 34,
        AAT_REBUILDTEXTURE = 35,
        AAT_RESTORE_RAW_MESH = 36,
        AAT_CANCEL_ALIGEN = 37,
        AAT_DELETE_MESH_FACE = 38,
        AAT_MULTI_PROJECT_ALIGING = 39,
        AAT_MULTI_PROJECT_CANCEL_ALIG = 40,
        AAT_MULTI_PROJECT_MESHING = 41,
        AAT_MULTI_PROJECT_REMOVE = 42,
        AAT_MULTI_PROJECT_APPLY_ALIG = 43,
        AAT_MULTI_PROJECT_APPLI_EDIT = 44,
        AAT_LOAING_SOLUTION = 45,
        AAT_MULTI_PROJECT_LOAD_SUB_PROJECT_DATA = 46,
        AAT_MULTI_PROJECT_LOAD_MAIN_PROJECT = 47,
        AAT_MULTI_PROJECT_SAVE = 48,
        AAT_MULTI_GENERATE_DATA = 49,
        AAT_POINT_TOO_LITTLE = 50,
        AAT_RECONNECT_DEVICE = 51,
        AAT_GENERATE_DATA = 52,
        AAT_REMOVE_SMALL_PART = 53,
        AAT_MESH_OPTIMATION = 54,
        ATT_MEMORY_DEFICIENCY = 55,
        ATT_ONLY_LOAD_FRAMER_MARKER = 56,
        ATT_CHANGE_FRAMERMARK_OR_POINTCLOUD_MODE = 57,
        ATT_UNKONW_ERROR = 58,
    };
#if (QT_VERSION >= QT_VERSION_CHECK(5, 5, 0))
    Q_ENUM(AsyncActionType)
#else
    Q_ENUMS(AsyncActionType)
#endif
    enum ServerNotifyType {
        SNT_FIX_SCAN_MARKER_TOO_MANY = 0,
    };
#if (QT_VERSION >= QT_VERSION_CHECK(5, 5, 0))
    Q_ENUM(ServerNotifyType)
#else
    Q_ENUMS(ServerNotifyType)
#endif

public:
    ScanServiceReplica() : QRemoteObjectReplica() { initialize(); }
    static void registerMetatypes()
    {
        static bool initialized = false;
        if (initialized)
            return;
        initialized = true;
        qRegisterMetaType<NewProjectParams>();
        qRegisterMetaTypeStreamOperators<NewProjectParams>();
        qRegisterMetaType<ScanStatus>();
        qRegisterMetaTypeStreamOperators<ScanStatus>();
        qRegisterMetaType<SubScanType>();
        qRegisterMetaTypeStreamOperators<SubScanType>();
        qRegisterMetaType<ScanObjInPortraitModeType>();
        qRegisterMetaTypeStreamOperators<ScanObjInPortraitModeType>();
        qRegisterMetaType<PointCloudMemoryHeader>();
        qRegisterMetaTypeStreamOperators<PointCloudMemoryHeader>();
        qRegisterMetaType<QVector<int>>();
        qRegisterMetaTypeStreamOperators<QVector<int>>();
        qRegisterMetaType<DeviceStatus>();
        qRegisterMetaTypeStreamOperators<DeviceStatus>();
        qRegisterMetaType<ChangeEventType>();
        qRegisterMetaTypeStreamOperators<ChangeEventType>();
        qRegisterMetaType<QList<QPair<QVariantMap, QList<QVariantMap>>>>();
        qRegisterMetaTypeStreamOperators<QList<QPair<QVariantMap, QList<QVariantMap>>>>();
        qRegisterMetaType<CameraPosition>();
        qRegisterMetaTypeStreamOperators<CameraPosition>();
        qRegisterMetaType<DeviceSeries>();
        qRegisterMetaTypeStreamOperators<DeviceSeries>();
        qRegisterMetaType<VideoDataMemoryHeader>();
        qRegisterMetaTypeStreamOperators<VideoDataMemoryHeader>();
        qRegisterMetaType<DeviceSubType>();
        qRegisterMetaTypeStreamOperators<DeviceSubType>();
        qRegisterMetaType<HoleLine>();
        qRegisterMetaTypeStreamOperators<HoleLine>();
        qRegisterMetaType<ScanParams>();
        qRegisterMetaTypeStreamOperators<ScanParams>();
        qRegisterMetaType<ScanObjType>();
        qRegisterMetaTypeStreamOperators<ScanObjType>();
        qRegisterMetaType<DeletePointsMemoryHeader>();
        qRegisterMetaTypeStreamOperators<DeletePointsMemoryHeader>();
        qRegisterMetaType<CaliType>();
        qRegisterMetaTypeStreamOperators<CaliType>();
        qRegisterMetaType<QVector<unsigned int>>();
        qRegisterMetaTypeStreamOperators<QVector<unsigned int>>();
        qRegisterMetaType<TriMesh>();
        qRegisterMetaTypeStreamOperators<TriMesh>();
        qRegisterMetaType<QVector<bool>>();
        qRegisterMetaTypeStreamOperators<QVector<bool>>();
        qRegisterMetaType<LaserScanType>();
        qRegisterMetaTypeStreamOperators<LaserScanType>();
        qRegisterMetaType<DeviceType>();
        qRegisterMetaTypeStreamOperators<DeviceType>();
        qRegisterMetaType<MeshType>();
        qRegisterMetaTypeStreamOperators<MeshType>();
        qRegisterMetaType<QVector<QVector3D>>();
        qRegisterMetaTypeStreamOperators<QVector<QVector3D>>();
        qRegisterMetaType<ActionResult>();
        qRegisterMetaTypeStreamOperators<ActionResult>();
        qRegisterMetaType<ModelColorType>();
        qRegisterMetaTypeStreamOperators<ModelColorType>();
        qRegisterMetaType<ScanType>();
        qRegisterMetaTypeStreamOperators<ScanType>();

    }

private:
    ScanServiceReplica(QRemoteObjectNode *node, const QString &name = QString())
        : QRemoteObjectReplica(ConstructWithNode)
        { initializeNode(node, name); }

    void initialize()
    {
        ScanServiceReplica::registerMetatypes();
        QVariantList properties;
        properties.reserve(103);
        properties << QVariant::fromValue(int());
        properties << QVariant::fromValue(bool());
        properties << QVariant::fromValue(QString());
        properties << QVariant::fromValue(int());
        properties << QVariant::fromValue(int());
        properties << QVariant::fromValue(int());
        properties << QVariant::fromValue(bool());
        properties << QVariant::fromValue(int());
        properties << QVariant::fromValue(QString());
        properties << QVariant::fromValue(DeviceType());
        properties << QVariant::fromValue(DeviceSeries());
        properties << QVariant::fromValue(DeviceSubType());
        properties << QVariant::fromValue(bool());
        properties << QVariant::fromValue(int());
        properties << QVariant::fromValue(bool());
        properties << QVariant::fromValue(DeviceStatus());
        properties << QVariant::fromValue(QVariantMap());
        properties << QVariant::fromValue(bool());
        properties << QVariant::fromValue(bool());
        properties << QVariant::fromValue(bool());
        properties << QVariant::fromValue(bool());
        properties << QVariant::fromValue(bool());
        properties << QVariant::fromValue(bool());
        properties << QVariant::fromValue(bool());
        properties << QVariant::fromValue(int());
        properties << QVariant::fromValue(int());
        properties << QVariant::fromValue(int());
        properties << QVariant::fromValue(int());
        properties << QVariant::fromValue(bool());
        properties << QVariant::fromValue(bool());
        properties << QVariant::fromValue(ModelColorType());
        properties << QVariant::fromValue(ScanObjType());
        properties << QVariant::fromValue(LaserScanType());
        properties << QVariant::fromValue(int());
        properties << QVariant::fromValue(ScanObjInPortraitModeType());
        properties << QVariant::fromValue(bool());
        properties << QVariant::fromValue(QVariantList());
        properties << QVariant::fromValue(QVariantList());
        properties << QVariant::fromValue(int());
        properties << QVariant::fromValue(int());
        properties << QVariant::fromValue(int());
        properties << QVariant::fromValue(bool());
        properties << QVariant::fromValue(int());
        properties << QVariant::fromValue(int());
        properties << QVariant::fromValue(int());
        properties << QVariant::fromValue(int());
        properties << QVariant::fromValue(int());
        properties << QVariant::fromValue(int());
        properties << QVariant::fromValue(QVariantList());
        properties << QVariant::fromValue(CameraPosition());
        properties << QVariant::fromValue(ScanType());
        properties << QVariant::fromValue(SubScanType());
        properties << QVariant::fromValue(int());
        properties << QVariant::fromValue(QString());
        properties << QVariant::fromValue(bool());
        properties << QVariant::fromValue(bool());
        properties << QVariant::fromValue(bool());
        properties << QVariant::fromValue(bool());
        properties << QVariant::fromValue(bool());
        properties << QVariant::fromValue(bool());
        properties << QVariant::fromValue(bool());
        properties << QVariant::fromValue(int());
        properties << QVariant::fromValue(QVariantList());
        properties << QVariant::fromValue(QVariantList());
        properties << QVariant::fromValue(float());
        properties << QVariant::fromValue(bool());
        properties << QVariant::fromValue(double());
        properties << QVariant::fromValue(QString());
        properties << QVariant::fromValue(bool());
        properties << QVariant::fromValue(CaliType());
        properties << QVariant::fromValue(bool());
        properties << QVariant::fromValue(int());
        properties << QVariant::fromValue(int());
        properties << QVariant::fromValue(QVariantMap());
        properties << QVariant::fromValue(QVector<bool>());
        properties << QVariant::fromValue(ScanStatus());
        properties << QVariant::fromValue(int());
        properties << QVariant::fromValue(bool());
        properties << QVariant::fromValue(bool());
        properties << QVariant::fromValue(bool());
        properties << QVariant::fromValue(bool());
        properties << QVariant::fromValue(bool());
        properties << QVariant::fromValue(bool());
        properties << QVariant::fromValue(bool());
        properties << QVariant::fromValue(int());
        properties << QVariant::fromValue(MeshType());
        properties << QVariant::fromValue(int());
        properties << QVariant::fromValue(int());
        properties << QVariant::fromValue(int());
        properties << QVariant::fromValue(QString());
        properties << QVariant::fromValue(int());
        properties << QVariant::fromValue(bool());
        properties << QVariant::fromValue(bool());
        properties << QVariant::fromValue(QVariantMap());
        properties << QVariant::fromValue(QVariantMap());
        properties << QVariant::fromValue(bool());
        properties << QVariant::fromValue(bool());
        properties << QVariant::fromValue(QString());
        properties << QVariant::fromValue(int());
        properties << QVariant::fromValue(bool());
        properties << QVariant::fromValue(bool());
        properties << QVariant::fromValue(bool());
        properties << QVariant::fromValue(double());
        setProperties(properties);
    }

public:
    virtual ~ScanServiceReplica() {}

    static inline ErrorCode toErrorCode(quint8 i, bool *ok = 0)
    {
        if (ok)
            *ok = true;
        switch (i) {
        case 0: return EC_NOERROR;
        case 1: return EC_PARAM_ERROR;
        case 2: return EC_ORDER_ERROR;
        case 3: return EC_TIME_OUT;
        case 4: return EC_NOT_SUPPORT;
        case 5: return EC_NO_DEVICE;
        case 6: return EC_DEVICE_LICENSE_ERROR;
        case 7: return EC_GPU_ERROR;
        case 8: return EC_INNER_ERROR;
        case 9: return EC_NOT_CALIBRATE;
        case 10: return EC_LOST_CONFIG_FILE;
        case 11: return EC_NO_DATAR;
        case 12: return EC_LOST_CALIBRATE_FILE;
        case 13: return EC_NO_GLOBAL_MARK_POINT_PARAM;
        default:
            if (ok)
                *ok = false;
            return EC_NOERROR;
        }
    }
    static inline DeviceType toDeviceType(quint8 i, bool *ok = 0)
    {
        if (ok)
            *ok = true;
        switch (i) {
        case 1: return DT_S;
        case 2: return DT_PRO;
        default:
            if (ok)
                *ok = false;
            return DT_S;
        }
    }
    static inline DeviceSeries toDeviceSeries(quint8 i, bool *ok = 0)
    {
        if (ok)
            *ok = true;
        switch (i) {
        case 1: return DEVICE_2X;
        case 2: return DEVICE_E7;
        case 3: return DEVICE_E3;
        case 4: return DEVICE_Ue;
        default:
            if (ok)
                *ok = false;
            return DEVICE_2X;
        }
    }
    static inline DeviceSubType toDeviceSubType(quint8 i, bool *ok = 0)
    {
        if (ok)
            *ok = true;
        switch (i) {
        case 1: return DST_PRO;
        case 2: return DST_PRO_PLUS;
        case 3: return DST_S_S10;
        case 5: return DST_S20;
        case 6: return DST_S2PLUS;
        case 8: return DST_E3_HX;
        case 9: return DST_E3_H;
        case 10: return DST_UE;
        default:
            if (ok)
                *ok = false;
            return DST_PRO;
        }
    }
    static inline DeviceStatus toDeviceStatus(quint8 i, bool *ok = 0)
    {
        if (ok)
            *ok = true;
        switch (i) {
        case 0: return DS_OFFLINE;
        case 1: return DS_ONLINE;
        default:
            if (ok)
                *ok = false;
            return DS_OFFLINE;
        }
    }
    static inline DeviceEvent toDeviceEvent(qint8 i, bool *ok = 0)
    {
        if (ok)
            *ok = true;
        switch (i) {
        case -1: return DE_NULL;
        case 0: return DE_DOUBLECLICK;
        case 1: return DE_CLICK;
        case 2: return DE_PLUS;
        case 3: return DE_SUB;
        case 4: return DE_E3_DISTANCE_PLUS;
        case 5: return DE_E3_DISTANCE_SUB;
        case 6: return DE_E3_TAP_POSITION_PLUS;
        case 7: return DE_E3_TAP_POSITION_SUB;
        case 8: return DE_LONGPRESS;
        case 9: return DE_UE_CENTER_BTN_MEN;
        case 10: return DE_UE_LBTN_LONGPRESS;
        case 11: return DE_UE_RBTN_LONGPRESS;
        case 12: return DE_UE_UBTN_DCLICK;
        case 13: return DE_UE_UBTN_LONGPRESS;
        case 14: return DE_UE_DBTN_DCLICK;
        case 15: return DE_UE_DBTN_LONGPRESS;
        case 16: return DE_UE_BTN_DCLICK;
        default:
            if (ok)
                *ok = false;
            return DE_NULL;
        }
    }
    static inline ScanType toScanType(quint8 i, bool *ok = 0)
    {
        if (ok)
            *ok = true;
        switch (i) {
        case 0: return ST_FIXED;
        case 1: return ST_HD;
        case 2: return ST_RAPID;
        case 3: return ST_E3_HX_NORMAL;
        case 4: return ST_E3_HX_LASER;
        case 5: return ST_E3_H_NORMAL;
        case 6: return ST_E3_H_BODY;
        case 7: return ST_E3_H_PORTRAIT;
        case 8: return ST_E3_CALIB;
        case 10: return ST_UE_LASER;
        default:
            if (ok)
                *ok = false;
            return ST_FIXED;
        }
    }
    static inline SubScanType toSubScanType(quint8 i, bool *ok = 0)
    {
        if (ok)
            *ok = true;
        switch (i) {
        case 0: return SST_FIXED_FREE;
        case 1: return SST_FIXED_TURNABLE;
        default:
            if (ok)
                *ok = false;
            return SST_FIXED_FREE;
        }
    }
    static inline CaliType toCaliType(quint8 i, bool *ok = 0)
    {
        if (ok)
            *ok = true;
        switch (i) {
        case 1: return CT_STEREO;
        case 2: return CT_HD;
        case 3: return CT_WHITE_BALANCE;
        case 4: return CT_DEFINITION;
        case 5: return CT_RAPID;
        case 6: return CT_LASER;
        default:
            if (ok)
                *ok = false;
            return CT_STEREO;
        }
    }
    static inline AlignType toAlignType(quint8 i, bool *ok = 0)
    {
        if (ok)
            *ok = true;
        switch (i) {
        case 0: return AT_FEATURES;
        case 1: return AT_MARKERS;
        case 2: return AT_HYBRID;
        case 4: return AT_AUTO;
        case 5: return AT_TURTABLE;
        case 6: return AT_CODE_POINT;
        case 7: return AT_GLOBAL_POINT;
        case 8: return AT_TEXTURE;
        default:
            if (ok)
                *ok = false;
            return AT_FEATURES;
        }
    }
    static inline ScanStatus toScanStatus(quint8 i, bool *ok = 0)
    {
        if (ok)
            *ok = true;
        switch (i) {
        case 1: return SS_PRE_SCAN;
        case 2: return SS_PRE_SCANNING;
        case 3: return SS_SCAN;
        case 4: return SS_PAUSED;
        case 5: return SS_SCAN_STOPED;
        default:
            if (ok)
                *ok = false;
            return SS_PRE_SCAN;
        }
    }
    static inline MemoryType toMemoryType(quint8 i, bool *ok = 0)
    {
        if (ok)
            *ok = true;
        switch (i) {
        case 0: return MT_POINT_CLOUD;
        case 1: return MT_DELETE_POINTS;
        case 2: return MT_MARKERS;
        case 3: return MT_TRI_MESH;
        case 4: return MT_VIDEO_DATA;
        case 5: return MT_RANGE_DATA;
        case 6: return MT_HOLE_LINE;
        case 7: return MT_FILL_HOLE_MESH;
        case 8: return MT_MULTI_PROJECT_POINT_CLOUD;
        case 9: return MT_BODY_SCAN_POINT_CLOUD;
        case 10: return MT_GENERATE_POINT_CLOUD_EDIT;
        default:
            if (ok)
                *ok = false;
            return MT_POINT_CLOUD;
        }
    }
    static inline MeshType toMeshType(quint8 i, bool *ok = 0)
    {
        if (ok)
            *ok = true;
        switch (i) {
        case 0: return MT_NON_WATERTIGHT;
        case 1: return MT_WATERTIGHT;
        default:
            if (ok)
                *ok = false;
            return MT_NON_WATERTIGHT;
        }
    }
    static inline ModelColorType toModelColorType(qint8 i, bool *ok = 0)
    {
        if (ok)
            *ok = true;
        switch (i) {
        case -1: return MCT_UNDEFINED;
        case 0: return MCT_BRIGHT;
        case 1: return MCT_DARK;
        case 2: return MCT_NORMAL;
        default:
            if (ok)
                *ok = false;
            return MCT_UNDEFINED;
        }
    }
    static inline ScanObjType toScanObjType(qint8 i, bool *ok = 0)
    {
        if (ok)
            *ok = true;
        switch (i) {
        case -1: return SOT_UNDEFINED;
        case 0: return SOT_NORMAL;
        case 1: return SOT_DARK;
        case 2: return SOT_REFLECT;
        default:
            if (ok)
                *ok = false;
            return SOT_UNDEFINED;
        }
    }
    static inline LaserScanType toLaserScanType(quint8 i, bool *ok = 0)
    {
        if (ok)
            *ok = true;
        switch (i) {
        case 0: return LST_SINGLE_LINE;
        case 1: return LST_MUTI_LINE;
        default:
            if (ok)
                *ok = false;
            return LST_SINGLE_LINE;
        }
    }
    static inline ScanObjInPortraitModeType toScanObjInPortraitModeType(quint8 i, bool *ok = 0)
    {
        if (ok)
            *ok = true;
        switch (i) {
        case 0: return SOPMT_HEAD;
        case 1: return SOPMT_BODY;
        default:
            if (ok)
                *ok = false;
            return SOPMT_HEAD;
        }
    }
    static inline ChangeEventType toChangeEventType(quint8 i, bool *ok = 0)
    {
        if (ok)
            *ok = true;
        switch (i) {
        case 0: return CET_BRIGHTNESS;
        case 1: return CET_SCANOBJ;
        case 2: return CET_BRIGHTNESS_QUALITY;
        case 3: return CET_BRIGHTNESS_LASER;
        case 4: return CET_BRIGHTNESS_LED;
        default:
            if (ok)
                *ok = false;
            return CET_BRIGHTNESS;
        }
    }
    static inline AsyncActionType toAsyncActionType(quint8 i, bool *ok = 0)
    {
        if (ok)
            *ok = true;
        switch (i) {
        case 0: return AAT_CHECK_DEVICE;
        case 1: return AAT_ENTER_CALI;
        case 2: return AAT_CHANGE_CALI_TYPE;
        case 3: return AAT_EXIT_CALI;
        case 4: return AAT_COMPUTE_CALI;
        case 5: return AAT_NEW_PROJECT;
        case 6: return AAT_OPEN_PROJECT;
        case 7: return AAT_ENTER_SCAN;
        case 8: return AAT_EXIT_SCAN;
        case 9: return AAT_CANCEL_SCAN;
        case 10: return AAT_END_SCAN;
        case 11: return AAT_SCAN;
        case 12: return AAT_WHITE_BAL;
        case 13: return AAT_MANUAL_ALIGN;
        case 14: return AAT_MESH;
        case 15: return AAT_SIMPLIFY;
        case 16: return AAT_EDIT;
        case 17: return AAT_EDIT_LIST;
        case 18: return AAT_DEL_POINT_CLOUD;
        case 19: return AAT_SAVE;
        case 20: return AAT_FIX_SINGLE_EDIT;
        case 21: return AAT_AXIS_VERIFY;
        case 22: return AAT_FIX_SCAN;
        case 23: return AAT_FIX_REMOVE_DATA;
        case 24: return AAT_FIX_UPDATE_DATA_RT;
        case 25: return AAT_EXPORT_SHARE_DATA;
        case 26: return AAT_LOAD_MODEL;
        case 27: return AAT_ENTER_POSTDATAPROCESS;
        case 28: return AAT_EXIT_POSTDATAPROCESS;
        case 29: return AAT_ENTER_FILL_HOLE_MODE;
        case 30: return AAT_APPLAY_FILLHOLE;
        case 31: return AAT_FILLING_HOLE;
        case 32: return AAT_SMOOTH;
        case 33: return AAT_SHARP;
        case 34: return AAT_ZOOM;
        case 35: return AAT_REBUILDTEXTURE;
        case 36: return AAT_RESTORE_RAW_MESH;
        case 37: return AAT_CANCEL_ALIGEN;
        case 38: return AAT_DELETE_MESH_FACE;
        case 39: return AAT_MULTI_PROJECT_ALIGING;
        case 40: return AAT_MULTI_PROJECT_CANCEL_ALIG;
        case 41: return AAT_MULTI_PROJECT_MESHING;
        case 42: return AAT_MULTI_PROJECT_REMOVE;
        case 43: return AAT_MULTI_PROJECT_APPLY_ALIG;
        case 44: return AAT_MULTI_PROJECT_APPLI_EDIT;
        case 45: return AAT_LOAING_SOLUTION;
        case 46: return AAT_MULTI_PROJECT_LOAD_SUB_PROJECT_DATA;
        case 47: return AAT_MULTI_PROJECT_LOAD_MAIN_PROJECT;
        case 48: return AAT_MULTI_PROJECT_SAVE;
        case 49: return AAT_MULTI_GENERATE_DATA;
        case 50: return AAT_POINT_TOO_LITTLE;
        case 51: return AAT_RECONNECT_DEVICE;
        case 52: return AAT_GENERATE_DATA;
        case 53: return AAT_REMOVE_SMALL_PART;
        case 54: return AAT_MESH_OPTIMATION;
        case 55: return ATT_MEMORY_DEFICIENCY;
        case 56: return ATT_ONLY_LOAD_FRAMER_MARKER;
        case 57: return ATT_CHANGE_FRAMERMARK_OR_POINTCLOUD_MODE;
        case 58: return ATT_UNKONW_ERROR;
        default:
            if (ok)
                *ok = false;
            return AAT_CHECK_DEVICE;
        }
    }
    static inline ServerNotifyType toServerNotifyType(quint8 i, bool *ok = 0)
    {
        if (ok)
            *ok = true;
        switch (i) {
        case 0: return SNT_FIX_SCAN_MARKER_TOO_MANY;
        default:
            if (ok)
                *ok = false;
            return SNT_FIX_SCAN_MARKER_TOO_MANY;
        }
    }
    int deviceBatch() const
    {
        const QVariant variant = propAsVariant(0);
        if (!variant.canConvert<int>()) {
            qWarning() << "QtRO cannot convert the property deviceBatch to type int";
        }
        return variant.value<int >();
    }

    bool deviceWithoutTextureCamera() const
    {
        const QVariant variant = propAsVariant(1);
        if (!variant.canConvert<bool>()) {
            qWarning() << "QtRO cannot convert the property deviceWithoutTextureCamera to type bool";
        }
        return variant.value<bool >();
    }

    QString deviceEdition() const
    {
        const QVariant variant = propAsVariant(2);
        if (!variant.canConvert<QString>()) {
            qWarning() << "QtRO cannot convert the property deviceEdition to type QString";
        }
        return variant.value<QString >();
    }

    int moveTooFast() const
    {
        const QVariant variant = propAsVariant(3);
        if (!variant.canConvert<int>()) {
            qWarning() << "QtRO cannot convert the property moveTooFast to type int";
        }
        return variant.value<int >();
    }

    int motiondetect() const
    {
        const QVariant variant = propAsVariant(4);
        if (!variant.canConvert<int>()) {
            qWarning() << "QtRO cannot convert the property motiondetect to type int";
        }
        return variant.value<int >();
    }

    void setMotiondetect(int motiondetect)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfProperty("motiondetect");
        QVariantList __repc_args;
        __repc_args << QVariant::fromValue(motiondetect);
        send(QMetaObject::WriteProperty, __repc_index, __repc_args);
    }

    int authSurplusDay() const
    {
        const QVariant variant = propAsVariant(5);
        if (!variant.canConvert<int>()) {
            qWarning() << "QtRO cannot convert the property authSurplusDay to type int";
        }
        return variant.value<int >();
    }

    void setAuthSurplusDay(int authSurplusDay)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfProperty("authSurplusDay");
        QVariantList __repc_args;
        __repc_args << QVariant::fromValue(authSurplusDay);
        send(QMetaObject::WriteProperty, __repc_index, __repc_args);
    }

    bool showOverdueDialog() const
    {
        const QVariant variant = propAsVariant(6);
        if (!variant.canConvert<bool>()) {
            qWarning() << "QtRO cannot convert the property showOverdueDialog to type bool";
        }
        return variant.value<bool >();
    }

    void setShowOverdueDialog(bool showOverdueDialog)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfProperty("showOverdueDialog");
        QVariantList __repc_args;
        __repc_args << QVariant::fromValue(showOverdueDialog);
        send(QMetaObject::WriteProperty, __repc_index, __repc_args);
    }

    int pleErrorType() const
    {
        const QVariant variant = propAsVariant(7);
        if (!variant.canConvert<int>()) {
            qWarning() << "QtRO cannot convert the property pleErrorType to type int";
        }
        return variant.value<int >();
    }

    void setPleErrorType(int pleErrorType)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfProperty("pleErrorType");
        QVariantList __repc_args;
        __repc_args << QVariant::fromValue(pleErrorType);
        send(QMetaObject::WriteProperty, __repc_index, __repc_args);
    }

    QString contactEMail() const
    {
        const QVariant variant = propAsVariant(8);
        if (!variant.canConvert<QString>()) {
            qWarning() << "QtRO cannot convert the property contactEMail to type QString";
        }
        return variant.value<QString >();
    }

    DeviceType deviceType() const
    {
        const QVariant variant = propAsVariant(9);
        if (!variant.canConvert<DeviceType>()) {
            qWarning() << "QtRO cannot convert the property deviceType to type DeviceType";
        }
        return variant.value<DeviceType >();
    }

    DeviceSeries deviceSeries() const
    {
        const QVariant variant = propAsVariant(10);
        if (!variant.canConvert<DeviceSeries>()) {
            qWarning() << "QtRO cannot convert the property deviceSeries to type DeviceSeries";
        }
        return variant.value<DeviceSeries >();
    }

    DeviceSubType deviceSubType() const
    {
        const QVariant variant = propAsVariant(11);
        if (!variant.canConvert<DeviceSubType>()) {
            qWarning() << "QtRO cannot convert the property deviceSubType to type DeviceSubType";
        }
        return variant.value<DeviceSubType >();
    }

    void setDeviceSubType(DeviceSubType deviceSubType)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfProperty("deviceSubType");
        QVariantList __repc_args;
        __repc_args << QVariant::fromValue(deviceSubType);
        send(QMetaObject::WriteProperty, __repc_index, __repc_args);
    }

    bool showHidePrimeVideo() const
    {
        const QVariant variant = propAsVariant(12);
        if (!variant.canConvert<bool>()) {
            qWarning() << "QtRO cannot convert the property showHidePrimeVideo to type bool";
        }
        return variant.value<bool >();
    }

    void setShowHidePrimeVideo(bool showHidePrimeVideo)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfProperty("showHidePrimeVideo");
        QVariantList __repc_args;
        __repc_args << QVariant::fromValue(showHidePrimeVideo);
        send(QMetaObject::WriteProperty, __repc_index, __repc_args);
    }

    int language() const
    {
        const QVariant variant = propAsVariant(13);
        if (!variant.canConvert<int>()) {
            qWarning() << "QtRO cannot convert the property language to type int";
        }
        return variant.value<int >();
    }

    void setLanguage(int language)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfProperty("language");
        QVariantList __repc_args;
        __repc_args << QVariant::fromValue(language);
        send(QMetaObject::WriteProperty, __repc_index, __repc_args);
    }

    bool x2Plus() const
    {
        const QVariant variant = propAsVariant(14);
        if (!variant.canConvert<bool>()) {
            qWarning() << "QtRO cannot convert the property x2Plus to type bool";
        }
        return variant.value<bool >();
    }

    DeviceStatus deviceStatus() const
    {
        const QVariant variant = propAsVariant(15);
        if (!variant.canConvert<DeviceStatus>()) {
            qWarning() << "QtRO cannot convert the property deviceStatus to type DeviceStatus";
        }
        return variant.value<DeviceStatus >();
    }

    void setDeviceStatus(DeviceStatus deviceStatus)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfProperty("deviceStatus");
        QVariantList __repc_args;
        __repc_args << QVariant::fromValue(deviceStatus);
        send(QMetaObject::WriteProperty, __repc_index, __repc_args);
    }

    QVariantMap caliInfo() const
    {
        const QVariant variant = propAsVariant(16);
        if (!variant.canConvert<QVariantMap>()) {
            qWarning() << "QtRO cannot convert the property caliInfo to type QVariantMap";
        }
        return variant.value<QVariantMap >();
    }

    bool hasIr() const
    {
        const QVariant variant = propAsVariant(17);
        if (!variant.canConvert<bool>()) {
            qWarning() << "QtRO cannot convert the property hasIr to type bool";
        }
        return variant.value<bool >();
    }

    bool hasColor() const
    {
        const QVariant variant = propAsVariant(18);
        if (!variant.canConvert<bool>()) {
            qWarning() << "QtRO cannot convert the property hasColor to type bool";
        }
        return variant.value<bool >();
    }

    bool isNeedShowColorGama() const
    {
        const QVariant variant = propAsVariant(19);
        if (!variant.canConvert<bool>()) {
            qWarning() << "QtRO cannot convert the property isNeedShowColorGama to type bool";
        }
        return variant.value<bool >();
    }

    bool isFirmwareVersionTextureAlignEnable() const
    {
        const QVariant variant = propAsVariant(20);
        if (!variant.canConvert<bool>()) {
            qWarning() << "QtRO cannot convert the property isFirmwareVersionTextureAlignEnable to type bool";
        }
        return variant.value<bool >();
    }

    bool hasDiscovery() const
    {
        const QVariant variant = propAsVariant(21);
        if (!variant.canConvert<bool>()) {
            qWarning() << "QtRO cannot convert the property hasDiscovery to type bool";
        }
        return variant.value<bool >();
    }

    bool globalmarkerScan() const
    {
        const QVariant variant = propAsVariant(22);
        if (!variant.canConvert<bool>()) {
            qWarning() << "QtRO cannot convert the property globalmarkerScan to type bool";
        }
        return variant.value<bool >();
    }

    bool firmwareUpgradable() const
    {
        const QVariant variant = propAsVariant(23);
        if (!variant.canConvert<bool>()) {
            qWarning() << "QtRO cannot convert the property firmwareUpgradable to type bool";
        }
        return variant.value<bool >();
    }

    int currentBrightness() const
    {
        const QVariant variant = propAsVariant(24);
        if (!variant.canConvert<int>()) {
            qWarning() << "QtRO cannot convert the property currentBrightness to type int";
        }
        return variant.value<int >();
    }

    void setCurrentBrightness(int currentBrightness)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfProperty("currentBrightness");
        QVariantList __repc_args;
        __repc_args << QVariant::fromValue(currentBrightness);
        send(QMetaObject::WriteProperty, __repc_index, __repc_args);
    }

    int currentLaserQualityStep() const
    {
        const QVariant variant = propAsVariant(25);
        if (!variant.canConvert<int>()) {
            qWarning() << "QtRO cannot convert the property currentLaserQualityStep to type int";
        }
        return variant.value<int >();
    }

    void setCurrentLaserQualityStep(int currentLaserQualityStep)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfProperty("currentLaserQualityStep");
        QVariantList __repc_args;
        __repc_args << QVariant::fromValue(currentLaserQualityStep);
        send(QMetaObject::WriteProperty, __repc_index, __repc_args);
    }

    int currentLaserBrightness() const
    {
        const QVariant variant = propAsVariant(26);
        if (!variant.canConvert<int>()) {
            qWarning() << "QtRO cannot convert the property currentLaserBrightness to type int";
        }
        return variant.value<int >();
    }

    void setCurrentLaserBrightness(int currentLaserBrightness)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfProperty("currentLaserBrightness");
        QVariantList __repc_args;
        __repc_args << QVariant::fromValue(currentLaserBrightness);
        send(QMetaObject::WriteProperty, __repc_index, __repc_args);
    }

    int currentLEDDutyCycle() const
    {
        const QVariant variant = propAsVariant(27);
        if (!variant.canConvert<int>()) {
            qWarning() << "QtRO cannot convert the property currentLEDDutyCycle to type int";
        }
        return variant.value<int >();
    }

    void setCurrentLEDDutyCycle(int currentLEDDutyCycle)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfProperty("currentLEDDutyCycle");
        QVariantList __repc_args;
        __repc_args << QVariant::fromValue(currentLEDDutyCycle);
        send(QMetaObject::WriteProperty, __repc_index, __repc_args);
    }

    bool isLedOpen() const
    {
        const QVariant variant = propAsVariant(28);
        if (!variant.canConvert<bool>()) {
            qWarning() << "QtRO cannot convert the property isLedOpen to type bool";
        }
        return variant.value<bool >();
    }

    void setIsLedOpen(bool isLedOpen)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfProperty("isLedOpen");
        QVariantList __repc_args;
        __repc_args << QVariant::fromValue(isLedOpen);
        send(QMetaObject::WriteProperty, __repc_index, __repc_args);
    }

    bool isPlaneDetectOpen() const
    {
        const QVariant variant = propAsVariant(29);
        if (!variant.canConvert<bool>()) {
            qWarning() << "QtRO cannot convert the property isPlaneDetectOpen to type bool";
        }
        return variant.value<bool >();
    }

    void setIsPlaneDetectOpen(bool isPlaneDetectOpen)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfProperty("isPlaneDetectOpen");
        QVariantList __repc_args;
        __repc_args << QVariant::fromValue(isPlaneDetectOpen);
        send(QMetaObject::WriteProperty, __repc_index, __repc_args);
    }

    ModelColorType modelColor() const
    {
        const QVariant variant = propAsVariant(30);
        if (!variant.canConvert<ModelColorType>()) {
            qWarning() << "QtRO cannot convert the property modelColor to type ModelColorType";
        }
        return variant.value<ModelColorType >();
    }

    void setModelColor(ModelColorType modelColor)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfProperty("modelColor");
        QVariantList __repc_args;
        __repc_args << QVariant::fromValue(modelColor);
        send(QMetaObject::WriteProperty, __repc_index, __repc_args);
    }

    ScanObjType scanObj() const
    {
        const QVariant variant = propAsVariant(31);
        if (!variant.canConvert<ScanObjType>()) {
            qWarning() << "QtRO cannot convert the property scanObj to type ScanObjType";
        }
        return variant.value<ScanObjType >();
    }

    void setScanObj(ScanObjType scanObj)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfProperty("scanObj");
        QVariantList __repc_args;
        __repc_args << QVariant::fromValue(scanObj);
        send(QMetaObject::WriteProperty, __repc_index, __repc_args);
    }

    LaserScanType laserScanType() const
    {
        const QVariant variant = propAsVariant(32);
        if (!variant.canConvert<LaserScanType>()) {
            qWarning() << "QtRO cannot convert the property laserScanType to type LaserScanType";
        }
        return variant.value<LaserScanType >();
    }

    void setLaserScanType(LaserScanType laserScanType)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfProperty("laserScanType");
        QVariantList __repc_args;
        __repc_args << QVariant::fromValue(laserScanType);
        send(QMetaObject::WriteProperty, __repc_index, __repc_args);
    }

    int e3MainBrightnessCtrl() const
    {
        const QVariant variant = propAsVariant(33);
        if (!variant.canConvert<int>()) {
            qWarning() << "QtRO cannot convert the property e3MainBrightnessCtrl to type int";
        }
        return variant.value<int >();
    }

    void setE3MainBrightnessCtrl(int e3MainBrightnessCtrl)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfProperty("e3MainBrightnessCtrl");
        QVariantList __repc_args;
        __repc_args << QVariant::fromValue(e3MainBrightnessCtrl);
        send(QMetaObject::WriteProperty, __repc_index, __repc_args);
    }

    ScanObjInPortraitModeType scanObjInPortraitModeType() const
    {
        const QVariant variant = propAsVariant(34);
        if (!variant.canConvert<ScanObjInPortraitModeType>()) {
            qWarning() << "QtRO cannot convert the property scanObjInPortraitModeType to type ScanObjInPortraitModeType";
        }
        return variant.value<ScanObjInPortraitModeType >();
    }

    void setScanObjInPortraitModeType(ScanObjInPortraitModeType scanObjInPortraitModeType)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfProperty("scanObjInPortraitModeType");
        QVariantList __repc_args;
        __repc_args << QVariant::fromValue(scanObjInPortraitModeType);
        send(QMetaObject::WriteProperty, __repc_index, __repc_args);
    }

    bool dataOptimiaztion() const
    {
        const QVariant variant = propAsVariant(35);
        if (!variant.canConvert<bool>()) {
            qWarning() << "QtRO cannot convert the property dataOptimiaztion to type bool";
        }
        return variant.value<bool >();
    }

    QVariantList brightnessRange() const
    {
        const QVariant variant = propAsVariant(36);
        if (!variant.canConvert<QVariantList>()) {
            qWarning() << "QtRO cannot convert the property brightnessRange to type QVariantList";
        }
        return variant.value<QVariantList >();
    }

    QVariantList laserQualityStepRange() const
    {
        const QVariant variant = propAsVariant(37);
        if (!variant.canConvert<QVariantList>()) {
            qWarning() << "QtRO cannot convert the property laserQualityStepRange to type QVariantList";
        }
        return variant.value<QVariantList >();
    }

    int frameCount() const
    {
        const QVariant variant = propAsVariant(38);
        if (!variant.canConvert<int>()) {
            qWarning() << "QtRO cannot convert the property frameCount to type int";
        }
        return variant.value<int >();
    }

    void setFrameCount(int frameCount)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfProperty("frameCount");
        QVariantList __repc_args;
        __repc_args << QVariant::fromValue(frameCount);
        send(QMetaObject::WriteProperty, __repc_index, __repc_args);
    }

    int exprotFramerMarkerCount() const
    {
        const QVariant variant = propAsVariant(39);
        if (!variant.canConvert<int>()) {
            qWarning() << "QtRO cannot convert the property exprotFramerMarkerCount to type int";
        }
        return variant.value<int >();
    }

    void setExprotFramerMarkerCount(int exprotFramerMarkerCount)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfProperty("exprotFramerMarkerCount");
        QVariantList __repc_args;
        __repc_args << QVariant::fromValue(exprotFramerMarkerCount);
        send(QMetaObject::WriteProperty, __repc_index, __repc_args);
    }

    int currentProjectMarkerCount() const
    {
        const QVariant variant = propAsVariant(40);
        if (!variant.canConvert<int>()) {
            qWarning() << "QtRO cannot convert the property currentProjectMarkerCount to type int";
        }
        return variant.value<int >();
    }

    void setCurrentProjectMarkerCount(int currentProjectMarkerCount)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfProperty("currentProjectMarkerCount");
        QVariantList __repc_args;
        __repc_args << QVariant::fromValue(currentProjectMarkerCount);
        send(QMetaObject::WriteProperty, __repc_index, __repc_args);
    }

    bool framerMarkHasNormal() const
    {
        const QVariant variant = propAsVariant(41);
        if (!variant.canConvert<bool>()) {
            qWarning() << "QtRO cannot convert the property framerMarkHasNormal to type bool";
        }
        return variant.value<bool >();
    }

    void setFramerMarkHasNormal(bool framerMarkHasNormal)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfProperty("framerMarkHasNormal");
        QVariantList __repc_args;
        __repc_args << QVariant::fromValue(framerMarkHasNormal);
        send(QMetaObject::WriteProperty, __repc_index, __repc_args);
    }

    int pointCount() const
    {
        const QVariant variant = propAsVariant(42);
        if (!variant.canConvert<int>()) {
            qWarning() << "QtRO cannot convert the property pointCount to type int";
        }
        return variant.value<int >();
    }

    void setPointCount(int pointCount)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfProperty("pointCount");
        QVariantList __repc_args;
        __repc_args << QVariant::fromValue(pointCount);
        send(QMetaObject::WriteProperty, __repc_index, __repc_args);
    }

    int pointFaceCount() const
    {
        const QVariant variant = propAsVariant(43);
        if (!variant.canConvert<int>()) {
            qWarning() << "QtRO cannot convert the property pointFaceCount to type int";
        }
        return variant.value<int >();
    }

    void setPointFaceCount(int pointFaceCount)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfProperty("pointFaceCount");
        QVariantList __repc_args;
        __repc_args << QVariant::fromValue(pointFaceCount);
        send(QMetaObject::WriteProperty, __repc_index, __repc_args);
    }

    int meshPointCount() const
    {
        const QVariant variant = propAsVariant(44);
        if (!variant.canConvert<int>()) {
            qWarning() << "QtRO cannot convert the property meshPointCount to type int";
        }
        return variant.value<int >();
    }

    void setMeshPointCount(int meshPointCount)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfProperty("meshPointCount");
        QVariantList __repc_args;
        __repc_args << QVariant::fromValue(meshPointCount);
        send(QMetaObject::WriteProperty, __repc_index, __repc_args);
    }

    int framerate() const
    {
        const QVariant variant = propAsVariant(45);
        if (!variant.canConvert<int>()) {
            qWarning() << "QtRO cannot convert the property framerate to type int";
        }
        return variant.value<int >();
    }

    int triangleCount() const
    {
        const QVariant variant = propAsVariant(46);
        if (!variant.canConvert<int>()) {
            qWarning() << "QtRO cannot convert the property triangleCount to type int";
        }
        return variant.value<int >();
    }

    void setTriangleCount(int triangleCount)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfProperty("triangleCount");
        QVariantList __repc_args;
        __repc_args << QVariant::fromValue(triangleCount);
        send(QMetaObject::WriteProperty, __repc_index, __repc_args);
    }

    int markerCount() const
    {
        const QVariant variant = propAsVariant(47);
        if (!variant.canConvert<int>()) {
            qWarning() << "QtRO cannot convert the property markerCount to type int";
        }
        return variant.value<int >();
    }

    QVariantList frameMemory() const
    {
        const QVariant variant = propAsVariant(48);
        if (!variant.canConvert<QVariantList>()) {
            qWarning() << "QtRO cannot convert the property frameMemory to type QVariantList";
        }
        return variant.value<QVariantList >();
    }

    CameraPosition cameraPosition() const
    {
        const QVariant variant = propAsVariant(49);
        if (!variant.canConvert<CameraPosition>()) {
            qWarning() << "QtRO cannot convert the property cameraPosition to type CameraPosition";
        }
        return variant.value<CameraPosition >();
    }

    ScanType scanType() const
    {
        const QVariant variant = propAsVariant(50);
        if (!variant.canConvert<ScanType>()) {
            qWarning() << "QtRO cannot convert the property scanType to type ScanType";
        }
        return variant.value<ScanType >();
    }

    void setScanType(ScanType scanType)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfProperty("scanType");
        QVariantList __repc_args;
        __repc_args << QVariant::fromValue(scanType);
        send(QMetaObject::WriteProperty, __repc_index, __repc_args);
    }

    SubScanType subScanType() const
    {
        const QVariant variant = propAsVariant(51);
        if (!variant.canConvert<SubScanType>()) {
            qWarning() << "QtRO cannot convert the property subScanType to type SubScanType";
        }
        return variant.value<SubScanType >();
    }

    void setSubScanType(SubScanType subScanType)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfProperty("subScanType");
        QVariantList __repc_args;
        __repc_args << QVariant::fromValue(subScanType);
        send(QMetaObject::WriteProperty, __repc_index, __repc_args);
    }

    int handleScanAlignType() const
    {
        const QVariant variant = propAsVariant(52);
        if (!variant.canConvert<int>()) {
            qWarning() << "QtRO cannot convert the property handleScanAlignType to type int";
        }
        return variant.value<int >();
    }

    QString lastProjectSavePath() const
    {
        const QVariant variant = propAsVariant(53);
        if (!variant.canConvert<QString>()) {
            qWarning() << "QtRO cannot convert the property lastProjectSavePath to type QString";
        }
        return variant.value<QString >();
    }

    bool hasMeshData() const
    {
        const QVariant variant = propAsVariant(54);
        if (!variant.canConvert<bool>()) {
            qWarning() << "QtRO cannot convert the property hasMeshData to type bool";
        }
        return variant.value<bool >();
    }

    bool isHDR() const
    {
        const QVariant variant = propAsVariant(55);
        if (!variant.canConvert<bool>()) {
            qWarning() << "QtRO cannot convert the property isHDR to type bool";
        }
        return variant.value<bool >();
    }

    bool useDiscovery() const
    {
        const QVariant variant = propAsVariant(56);
        if (!variant.canConvert<bool>()) {
            qWarning() << "QtRO cannot convert the property useDiscovery to type bool";
        }
        return variant.value<bool >();
    }

    bool hasLightBox() const
    {
        const QVariant variant = propAsVariant(57);
        if (!variant.canConvert<bool>()) {
            qWarning() << "QtRO cannot convert the property hasLightBox to type bool";
        }
        return variant.value<bool >();
    }

    bool lightBoxOpen() const
    {
        const QVariant variant = propAsVariant(58);
        if (!variant.canConvert<bool>()) {
            qWarning() << "QtRO cannot convert the property lightBoxOpen to type bool";
        }
        return variant.value<bool >();
    }

    bool hasTurntable() const
    {
        const QVariant variant = propAsVariant(59);
        if (!variant.canConvert<bool>()) {
            qWarning() << "QtRO cannot convert the property hasTurntable to type bool";
        }
        return variant.value<bool >();
    }

    bool scanWithTexture() const
    {
        const QVariant variant = propAsVariant(60);
        if (!variant.canConvert<bool>()) {
            qWarning() << "QtRO cannot convert the property scanWithTexture to type bool";
        }
        return variant.value<bool >();
    }

    void setScanWithTexture(bool scanWithTexture)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfProperty("scanWithTexture");
        QVariantList __repc_args;
        __repc_args << QVariant::fromValue(scanWithTexture);
        send(QMetaObject::WriteProperty, __repc_index, __repc_args);
    }

    int solutionWithTexture() const
    {
        const QVariant variant = propAsVariant(61);
        if (!variant.canConvert<int>()) {
            qWarning() << "QtRO cannot convert the property solutionWithTexture to type int";
        }
        return variant.value<int >();
    }

    void setSolutionWithTexture(int solutionWithTexture)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfProperty("solutionWithTexture");
        QVariantList __repc_args;
        __repc_args << QVariant::fromValue(solutionWithTexture);
        send(QMetaObject::WriteProperty, __repc_index, __repc_args);
    }

    QVariantList pointDistRange() const
    {
        const QVariant variant = propAsVariant(62);
        if (!variant.canConvert<QVariantList>()) {
            qWarning() << "QtRO cannot convert the property pointDistRange to type QVariantList";
        }
        return variant.value<QVariantList >();
    }

    QVariantList resolutionValue() const
    {
        const QVariant variant = propAsVariant(63);
        if (!variant.canConvert<QVariantList>()) {
            qWarning() << "QtRO cannot convert the property resolutionValue to type QVariantList";
        }
        return variant.value<QVariantList >();
    }

    float currentPointDist() const
    {
        const QVariant variant = propAsVariant(64);
        if (!variant.canConvert<float>()) {
            qWarning() << "QtRO cannot convert the property currentPointDist to type float";
        }
        return variant.value<float >();
    }

    void setCurrentPointDist(float currentPointDist)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfProperty("currentPointDist");
        QVariantList __repc_args;
        __repc_args << QVariant::fromValue(currentPointDist);
        send(QMetaObject::WriteProperty, __repc_index, __repc_args);
    }

    bool microspurPointDist() const
    {
        const QVariant variant = propAsVariant(65);
        if (!variant.canConvert<bool>()) {
            qWarning() << "QtRO cannot convert the property microspurPointDist to type bool";
        }
        return variant.value<bool >();
    }

    void setMicrospurPointDist(bool microspurPointDist)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfProperty("microspurPointDist");
        QVariantList __repc_args;
        __repc_args << QVariant::fromValue(microspurPointDist);
        send(QMetaObject::WriteProperty, __repc_index, __repc_args);
    }

    double currentPointDistStep() const
    {
        const QVariant variant = propAsVariant(66);
        if (!variant.canConvert<double>()) {
            qWarning() << "QtRO cannot convert the property currentPointDistStep to type double";
        }
        return variant.value<double >();
    }

    void setCurrentPointDistStep(double currentPointDistStep)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfProperty("currentPointDistStep");
        QVariantList __repc_args;
        __repc_args << QVariant::fromValue(currentPointDistStep);
        send(QMetaObject::WriteProperty, __repc_index, __repc_args);
    }

    QString currentPle() const
    {
        const QVariant variant = propAsVariant(67);
        if (!variant.canConvert<QString>()) {
            qWarning() << "QtRO cannot convert the property currentPle to type QString";
        }
        return variant.value<QString >();
    }

    bool snapEnabled() const
    {
        const QVariant variant = propAsVariant(68);
        if (!variant.canConvert<bool>()) {
            qWarning() << "QtRO cannot convert the property snapEnabled to type bool";
        }
        return variant.value<bool >();
    }

    void setSnapEnabled(bool snapEnabled)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfProperty("snapEnabled");
        QVariantList __repc_args;
        __repc_args << QVariant::fromValue(snapEnabled);
        send(QMetaObject::WriteProperty, __repc_index, __repc_args);
    }

    CaliType caliType() const
    {
        const QVariant variant = propAsVariant(69);
        if (!variant.canConvert<CaliType>()) {
            qWarning() << "QtRO cannot convert the property caliType to type CaliType";
        }
        return variant.value<CaliType >();
    }

    void setCaliType(CaliType caliType)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfProperty("caliType");
        QVariantList __repc_args;
        __repc_args << QVariant::fromValue(caliType);
        send(QMetaObject::WriteProperty, __repc_index, __repc_args);
    }

    bool isCalibGuidePageVisible() const
    {
        const QVariant variant = propAsVariant(70);
        if (!variant.canConvert<bool>()) {
            qWarning() << "QtRO cannot convert the property isCalibGuidePageVisible to type bool";
        }
        return variant.value<bool >();
    }

    void setIsCalibGuidePageVisible(bool isCalibGuidePageVisible)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfProperty("isCalibGuidePageVisible");
        QVariantList __repc_args;
        __repc_args << QVariant::fromValue(isCalibGuidePageVisible);
        send(QMetaObject::WriteProperty, __repc_index, __repc_args);
    }

    int currentCaliGroup() const
    {
        const QVariant variant = propAsVariant(71);
        if (!variant.canConvert<int>()) {
            qWarning() << "QtRO cannot convert the property currentCaliGroup to type int";
        }
        return variant.value<int >();
    }

    void setCurrentCaliGroup(int currentCaliGroup)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfProperty("currentCaliGroup");
        QVariantList __repc_args;
        __repc_args << QVariant::fromValue(currentCaliGroup);
        send(QMetaObject::WriteProperty, __repc_index, __repc_args);
    }

    int currentCaliDist() const
    {
        const QVariant variant = propAsVariant(72);
        if (!variant.canConvert<int>()) {
            qWarning() << "QtRO cannot convert the property currentCaliDist to type int";
        }
        return variant.value<int >();
    }

    QVariantMap postProcessParam() const
    {
        const QVariant variant = propAsVariant(73);
        if (!variant.canConvert<QVariantMap>()) {
            qWarning() << "QtRO cannot convert the property postProcessParam to type QVariantMap";
        }
        return variant.value<QVariantMap >();
    }

    QVector<bool> caliDistStates() const
    {
        const QVariant variant = propAsVariant(74);
        if (!variant.canConvert<QVector<bool>>()) {
            qWarning() << "QtRO cannot convert the property caliDistStates to type QVector<bool>";
        }
        return variant.value<QVector<bool> >();
    }

    ScanStatus scanStatus() const
    {
        const QVariant variant = propAsVariant(75);
        if (!variant.canConvert<ScanStatus>()) {
            qWarning() << "QtRO cannot convert the property scanStatus to type ScanStatus";
        }
        return variant.value<ScanStatus >();
    }

    int scanDist() const
    {
        const QVariant variant = propAsVariant(76);
        if (!variant.canConvert<int>()) {
            qWarning() << "QtRO cannot convert the property scanDist to type int";
        }
        return variant.value<int >();
    }

    bool rapidMode() const
    {
        const QVariant variant = propAsVariant(77);
        if (!variant.canConvert<bool>()) {
            qWarning() << "QtRO cannot convert the property rapidMode to type bool";
        }
        return variant.value<bool >();
    }

    bool rapidSave() const
    {
        const QVariant variant = propAsVariant(78);
        if (!variant.canConvert<bool>()) {
            qWarning() << "QtRO cannot convert the property rapidSave to type bool";
        }
        return variant.value<bool >();
    }

    bool noMarkerDetected() const
    {
        const QVariant variant = propAsVariant(79);
        if (!variant.canConvert<bool>()) {
            qWarning() << "QtRO cannot convert the property noMarkerDetected to type bool";
        }
        return variant.value<bool >();
    }

    bool tooFlat() const
    {
        const QVariant variant = propAsVariant(80);
        if (!variant.canConvert<bool>()) {
            qWarning() << "QtRO cannot convert the property tooFlat to type bool";
        }
        return variant.value<bool >();
    }

    bool trackLost() const
    {
        const QVariant variant = propAsVariant(81);
        if (!variant.canConvert<bool>()) {
            qWarning() << "QtRO cannot convert the property trackLost to type bool";
        }
        return variant.value<bool >();
    }

    bool updateFirm() const
    {
        const QVariant variant = propAsVariant(82);
        if (!variant.canConvert<bool>()) {
            qWarning() << "QtRO cannot convert the property updateFirm to type bool";
        }
        return variant.value<bool >();
    }

    void setUpdateFirm(bool updateFirm)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfProperty("updateFirm");
        QVariantList __repc_args;
        __repc_args << QVariant::fromValue(updateFirm);
        send(QMetaObject::WriteProperty, __repc_index, __repc_args);
    }

    bool showCalibVideo() const
    {
        const QVariant variant = propAsVariant(83);
        if (!variant.canConvert<bool>()) {
            qWarning() << "QtRO cannot convert the property showCalibVideo to type bool";
        }
        return variant.value<bool >();
    }

    int progress() const
    {
        const QVariant variant = propAsVariant(84);
        if (!variant.canConvert<int>()) {
            qWarning() << "QtRO cannot convert the property progress to type int";
        }
        return variant.value<int >();
    }

    MeshType lastMeshType() const
    {
        const QVariant variant = propAsVariant(85);
        if (!variant.canConvert<MeshType>()) {
            qWarning() << "QtRO cannot convert the property lastMeshType to type MeshType";
        }
        return variant.value<MeshType >();
    }

    int lastMeshDetail() const
    {
        const QVariant variant = propAsVariant(86);
        if (!variant.canConvert<int>()) {
            qWarning() << "QtRO cannot convert the property lastMeshDetail to type int";
        }
        return variant.value<int >();
    }

    int minRemainMemory() const
    {
        const QVariant variant = propAsVariant(87);
        if (!variant.canConvert<int>()) {
            qWarning() << "QtRO cannot convert the property minRemainMemory to type int";
        }
        return variant.value<int >();
    }

    int minRemainDisk() const
    {
        const QVariant variant = propAsVariant(88);
        if (!variant.canConvert<int>()) {
            qWarning() << "QtRO cannot convert the property minRemainDisk to type int";
        }
        return variant.value<int >();
    }

    QString currentProjectPath() const
    {
        const QVariant variant = propAsVariant(89);
        if (!variant.canConvert<QString>()) {
            qWarning() << "QtRO cannot convert the property currentProjectPath to type QString";
        }
        return variant.value<QString >();
    }

    int currentTurntableSteps() const
    {
        const QVariant variant = propAsVariant(90);
        if (!variant.canConvert<int>()) {
            qWarning() << "QtRO cannot convert the property currentTurntableSteps to type int";
        }
        return variant.value<int >();
    }

    void setCurrentTurntableSteps(int currentTurntableSteps)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfProperty("currentTurntableSteps");
        QVariantList __repc_args;
        __repc_args << QVariant::fromValue(currentTurntableSteps);
        send(QMetaObject::WriteProperty, __repc_index, __repc_args);
    }

    bool isTextureAlignEnable() const
    {
        const QVariant variant = propAsVariant(91);
        if (!variant.canConvert<bool>()) {
            qWarning() << "QtRO cannot convert the property isTextureAlignEnable to type bool";
        }
        return variant.value<bool >();
    }

    void setIsTextureAlignEnable(bool isTextureAlignEnable)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfProperty("isTextureAlignEnable");
        QVariantList __repc_args;
        __repc_args << QVariant::fromValue(isTextureAlignEnable);
        send(QMetaObject::WriteProperty, __repc_index, __repc_args);
    }

    bool isCurrentProjectHasMarker() const
    {
        const QVariant variant = propAsVariant(92);
        if (!variant.canConvert<bool>()) {
            qWarning() << "QtRO cannot convert the property isCurrentProjectHasMarker to type bool";
        }
        return variant.value<bool >();
    }

    QVariantMap lastSimpleParams() const
    {
        const QVariant variant = propAsVariant(93);
        if (!variant.canConvert<QVariantMap>()) {
            qWarning() << "QtRO cannot convert the property lastSimpleParams to type QVariantMap";
        }
        return variant.value<QVariantMap >();
    }

    QVariantMap lastSaveResizeParams() const
    {
        const QVariant variant = propAsVariant(94);
        if (!variant.canConvert<QVariantMap>()) {
            qWarning() << "QtRO cannot convert the property lastSaveResizeParams to type QVariantMap";
        }
        return variant.value<QVariantMap >();
    }

    bool isInternal() const
    {
        const QVariant variant = propAsVariant(95);
        if (!variant.canConvert<bool>()) {
            qWarning() << "QtRO cannot convert the property isInternal to type bool";
        }
        return variant.value<bool >();
    }

    bool isRightPrivateDebugFile() const
    {
        const QVariant variant = propAsVariant(96);
        if (!variant.canConvert<bool>()) {
            qWarning() << "QtRO cannot convert the property isRightPrivateDebugFile to type bool";
        }
        return variant.value<bool >();
    }

    QString currentSlnPath() const
    {
        const QVariant variant = propAsVariant(97);
        if (!variant.canConvert<QString>()) {
            qWarning() << "QtRO cannot convert the property currentSlnPath to type QString";
        }
        return variant.value<QString >();
    }

    int globalOptimization() const
    {
        const QVariant variant = propAsVariant(98);
        if (!variant.canConvert<int>()) {
            qWarning() << "QtRO cannot convert the property globalOptimization to type int";
        }
        return variant.value<int >();
    }

    bool meshDataHasMarker() const
    {
        const QVariant variant = propAsVariant(99);
        if (!variant.canConvert<bool>()) {
            qWarning() << "QtRO cannot convert the property meshDataHasMarker to type bool";
        }
        return variant.value<bool >();
    }

    bool isMeshDataWarterTight() const
    {
        const QVariant variant = propAsVariant(100);
        if (!variant.canConvert<bool>()) {
            qWarning() << "QtRO cannot convert the property isMeshDataWarterTight to type bool";
        }
        return variant.value<bool >();
    }

    bool isBigWorkRange() const
    {
        const QVariant variant = propAsVariant(101);
        if (!variant.canConvert<bool>()) {
            qWarning() << "QtRO cannot convert the property isBigWorkRange to type bool";
        }
        return variant.value<bool >();
    }

    void setIsBigWorkRange(bool isBigWorkRange)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfProperty("isBigWorkRange");
        QVariantList __repc_args;
        __repc_args << QVariant::fromValue(isBigWorkRange);
        send(QMetaObject::WriteProperty, __repc_index, __repc_args);
    }

    double currentSolutionPointDist() const
    {
        const QVariant variant = propAsVariant(102);
        if (!variant.canConvert<double>()) {
            qWarning() << "QtRO cannot convert the property currentSolutionPointDist to type double";
        }
        return variant.value<double >();
    }

    void setCurrentSolutionPointDist(double currentSolutionPointDist)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfProperty("currentSolutionPointDist");
        QVariantList __repc_args;
        __repc_args << QVariant::fromValue(currentSolutionPointDist);
        send(QMetaObject::WriteProperty, __repc_index, __repc_args);
    }


Q_SIGNALS:
    void deviceBatchChanged(int);
    void deviceWithoutTextureCameraChanged(bool);
    void deviceEditionChanged(QString);
    void moveTooFastChanged(int);
    void motiondetectChanged(int);
    void authSurplusDayChanged(int);
    void showOverdueDialogChanged(bool);
    void pleErrorTypeChanged(int);
    void contactEMailChanged(QString);
    void deviceTypeChanged(ScanServiceReplica::DeviceType);
    void deviceSeriesChanged(ScanServiceReplica::DeviceSeries);
    void deviceSubTypeChanged(ScanServiceReplica::DeviceSubType);
    void showHidePrimeVideoChanged(bool);
    void languageChanged(int);
    void x2PlusChanged(bool);
    void deviceStatusChanged(ScanServiceReplica::DeviceStatus);
    void caliInfoChanged(QVariantMap);
    void hasIrChanged(bool);
    void hasColorChanged(bool);
    void isNeedShowColorGamaChanged(bool);
    void isFirmwareVersionTextureAlignEnableChanged(bool);
    void hasDiscoveryChanged(bool);
    void globalmarkerScanChanged(bool);
    void firmwareUpgradableChanged(bool);
    void currentBrightnessChanged(int);
    void currentLaserQualityStepChanged(int);
    void currentLaserBrightnessChanged(int);
    void currentLEDDutyCycleChanged(int);
    void isLedOpenChanged(bool);
    void isPlaneDetectOpenChanged(bool);
    void modelColorChanged(ScanServiceReplica::ModelColorType);
    void scanObjChanged(ScanServiceReplica::ScanObjType);
    void laserScanTypeChanged(ScanServiceReplica::LaserScanType);
    void e3MainBrightnessCtrlChanged(int);
    void scanObjInPortraitModeTypeChanged(ScanServiceReplica::ScanObjInPortraitModeType);
    void dataOptimiaztionChanged(bool);
    void brightnessRangeChanged(QVariantList);
    void laserQualityStepRangeChanged(QVariantList);
    void frameCountChanged(int);
    void exprotFramerMarkerCountChanged(int);
    void currentProjectMarkerCountChanged(int);
    void framerMarkHasNormalChanged(bool);
    void pointCountChanged(int);
    void pointFaceCountChanged(int);
    void meshPointCountChanged(int);
    void framerateChanged(int);
    void triangleCountChanged(int);
    void markerCountChanged(int);
    void frameMemoryChanged(QVariantList);
    void cameraPositionChanged(CameraPosition);
    void scanTypeChanged(ScanServiceReplica::ScanType);
    void subScanTypeChanged(ScanServiceReplica::SubScanType);
    void handleScanAlignTypeChanged(int);
    void lastProjectSavePathChanged(QString);
    void hasMeshDataChanged(bool);
    void isHDRChanged(bool);
    void useDiscoveryChanged(bool);
    void hasLightBoxChanged(bool);
    void lightBoxOpenChanged(bool);
    void hasTurntableChanged(bool);
    void scanWithTextureChanged(bool);
    void solutionWithTextureChanged(int);
    void pointDistRangeChanged(QVariantList);
    void resolutionValueChanged(QVariantList);
    void currentPointDistChanged(float);
    void microspurPointDistChanged(bool);
    void currentPointDistStepChanged(double);
    void currentPleChanged(QString);
    void snapEnabledChanged(bool);
    void caliTypeChanged(ScanServiceReplica::CaliType);
    void isCalibGuidePageVisibleChanged(bool);
    void currentCaliGroupChanged(int);
    void currentCaliDistChanged(int);
    void postProcessParamChanged(QVariantMap);
    void caliDistStatesChanged(QVector<bool>);
    void scanStatusChanged(ScanServiceReplica::ScanStatus);
    void scanDistChanged(int);
    void rapidModeChanged(bool);
    void rapidSaveChanged(bool);
    void noMarkerDetectedChanged(bool);
    void tooFlatChanged(bool);
    void trackLostChanged(bool);
    void updateFirmChanged(bool);
    void showCalibVideoChanged(bool);
    void progressChanged(int);
    void lastMeshTypeChanged(ScanServiceReplica::MeshType);
    void lastMeshDetailChanged(int);
    void minRemainMemoryChanged(int);
    void minRemainDiskChanged(int);
    void currentProjectPathChanged(QString);
    void currentTurntableStepsChanged(int);
    void isTextureAlignEnableChanged(bool);
    void isCurrentProjectHasMarkerChanged(bool);
    void lastSimpleParamsChanged(QVariantMap);
    void lastSaveResizeParamsChanged(QVariantMap);
    void isInternalChanged(bool);
    void isRightPrivateDebugFileChanged(bool);
    void currentSlnPathChanged(QString);
    void globalOptimizationChanged(int);
    void meshDataHasMarkerChanged(bool);
    void isMeshDataWarterTightChanged(bool);
    void isBigWorkRangeChanged(bool);
    void currentSolutionPointDistChanged(double);
    void eventOccurred(int event);
    void sceneZoomChange(QVariantMap val);
    void serverNotify(int eventType, QVariantMap eventParams);
    void dataReady(QString memoryKey, int memoryType);
    void multiDataReady(QVariantMap data, int memoryType);
    void postTriMesh(TriMesh mesh);
    void postHoleLine(HoleLine line);
    void beginAsyncAction(int type, QVariantMap props);
    void finishAsyncAction(int type, ActionResult result, QVariantMap props);
    void calibButtonClicked(bool isCalibRun);
    void calibMoveTipChanged(int moveDir);
    void oneEditDataChanged(QString memoryKey);
    void fixedProjectsChanged(QList<QPair<QVariantMap, QList<QVariantMap>>> info);
    void checkSlnOrProjFinish(QString filepath, int errorCode);
    void fixedAlignManualFinish();
    void informationFromCalibChanged(QVariantMap props);

public Q_SLOTS:
    void pushLightBoxOpen(bool lightBoxOpen)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("pushLightBoxOpen(bool)");
        QVariantList __repc_args;
        __repc_args << QVariant::fromValue(lightBoxOpen);
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void pushHasTurntable(bool hasTurntable)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("pushHasTurntable(bool)");
        QVariantList __repc_args;
        __repc_args << QVariant::fromValue(hasTurntable);
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void pushCurrentPle(QString currentPle)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("pushCurrentPle(QString)");
        QVariantList __repc_args;
        __repc_args << QVariant::fromValue(currentPle);
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void checkSlnOrProjLegal(QString Path, bool isProj)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("checkSlnOrProjLegal(QString,bool)");
        QVariantList __repc_args;
        __repc_args
            << QVariant::fromValue(Path)
            << QVariant::fromValue(isProj)
        ;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void checkDevice()
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("checkDevice()");
        QVariantList __repc_args;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void checkImportPLE()
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("checkImportPLE()");
        QVariantList __repc_args;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void updateRegTime()
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("updateRegTime()");
        QVariantList __repc_args;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void newProject(QString path, NewProjectParams params)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("newProject(QString,NewProjectParams)");
        QVariantList __repc_args;
        __repc_args
            << QVariant::fromValue(path)
            << QVariant::fromValue(params)
        ;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void loadFramerMarker(QString path)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("loadFramerMarker(QString)");
        QVariantList __repc_args;
        __repc_args
            << QVariant::fromValue(path)
        ;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void openProject(QString path, ScanType type)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("openProject(QString,ScanType)");
        QVariantList __repc_args;
        __repc_args
            << QVariant::fromValue(path)
            << QVariant::fromValue(type)
        ;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void enterScan(ScanType type)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("enterScan(ScanType)");
        QVariantList __repc_args;
        __repc_args
            << QVariant::fromValue(type)
        ;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void exitScan()
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("exitScan()");
        QVariantList __repc_args;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void setIsCH(bool isCH)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("setIsCH(bool)");
        QVariantList __repc_args;
        __repc_args
            << QVariant::fromValue(isCH)
        ;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void startScan(ScanParams params)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("startScan(ScanParams)");
        QVariantList __repc_args;
        __repc_args
            << QVariant::fromValue(params)
        ;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void pauseScan()
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("pauseScan()");
        QVariantList __repc_args;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void endScan(bool globalOptimize, float pointDist, bool reBuildData)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("endScan(bool,float,bool)");
        QVariantList __repc_args;
        __repc_args
            << QVariant::fromValue(globalOptimize)
            << QVariant::fromValue(pointDist)
            << QVariant::fromValue(reBuildData)
        ;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void SingleCorssChanged(int mode)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("SingleCorssChanged(int)");
        QVariantList __repc_args;
        __repc_args
            << QVariant::fromValue(mode)
        ;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void setDeviceBtnEnable(bool disable)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("setDeviceBtnEnable(bool)");
        QVariantList __repc_args;
        __repc_args
            << QVariant::fromValue(disable)
        ;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void setDeviceZoomBtnDisable(bool disable)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("setDeviceZoomBtnDisable(bool)");
        QVariantList __repc_args;
        __repc_args
            << QVariant::fromValue(disable)
        ;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void cancelScan(QVariantList dataNames, bool isCancelCurrentProjectFramerMark)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("cancelScan(QVariantList,bool)");
        QVariantList __repc_args;
        __repc_args
            << QVariant::fromValue(dataNames)
            << QVariant::fromValue(isCancelCurrentProjectFramerMark)
        ;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void changeScanObjInPortraitModeType()
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("changeScanObjInPortraitModeType()");
        QVariantList __repc_args;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void sendChangeEventFromQml(ChangeEventType type, QVariant val)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("sendChangeEventFromQml(ChangeEventType,QVariant)");
        QVariantList __repc_args;
        __repc_args
            << QVariant::fromValue(type)
            << QVariant::fromValue(val)
        ;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void enterProCali()
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("enterProCali()");
        QVariantList __repc_args;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void exitProCali()
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("exitProCali()");
        QVariantList __repc_args;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void testWhiteBalance()
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("testWhiteBalance()");
        QVariantList __repc_args;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void applySingleEdit(bool apply, QStringList names)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("applySingleEdit(bool,QStringList)");
        QVariantList __repc_args;
        __repc_args
            << QVariant::fromValue(apply)
            << QVariant::fromValue(names)
        ;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void cancelSingleEdit(bool apply, QStringList names)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("cancelSingleEdit(bool,QStringList)");
        QVariantList __repc_args;
        __repc_args
            << QVariant::fromValue(apply)
            << QVariant::fromValue(names)
        ;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void applyEdit(bool apply, QString memoryKey, int totalProject, int currentProjectIndex)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("applyEdit(bool,QString,int,int)");
        QVariantList __repc_args;
        __repc_args
            << QVariant::fromValue(apply)
            << QVariant::fromValue(memoryKey)
            << QVariant::fromValue(totalProject)
            << QVariant::fromValue(currentProjectIndex)
        ;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void updateMeshParam(bool mesh, QStringList nameList)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("updateMeshParam(bool,QStringList)");
        QVariantList __repc_args;
        __repc_args
            << QVariant::fromValue(mesh)
            << QVariant::fromValue(nameList)
        ;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void applyEditList(QStringList groupFix, QStringList groupFloat)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("applyEditList(QStringList,QStringList)");
        QVariantList __repc_args;
        __repc_args
            << QVariant::fromValue(groupFix)
            << QVariant::fromValue(groupFloat)
        ;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void deletePointCloud(QString name)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("deletePointCloud(QString)");
        QVariantList __repc_args;
        __repc_args
            << QVariant::fromValue(name)
        ;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void mesh(MeshType meshType, int resolution)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("mesh(MeshType,int)");
        QVariantList __repc_args;
        __repc_args
            << QVariant::fromValue(meshType)
            << QVariant::fromValue(resolution)
        ;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void simplify(QVariantMap params)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("simplify(QVariantMap)");
        QVariantList __repc_args;
        __repc_args
            << QVariant::fromValue(params)
        ;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void smooth(QVariantMap params)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("smooth(QVariantMap)");
        QVariantList __repc_args;
        __repc_args
            << QVariant::fromValue(params)
        ;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void removeSmallPart(QVariantMap params)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("removeSmallPart(QVariantMap)");
        QVariantList __repc_args;
        __repc_args
            << QVariant::fromValue(params)
        ;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void getCopyMeshFnVn()
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("getCopyMeshFnVn()");
        QVariantList __repc_args;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void meshOptimation(QVariantMap params)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("meshOptimation(QVariantMap)");
        QVariantList __repc_args;
        __repc_args
            << QVariant::fromValue(params)
        ;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void sharp(QVariantMap params)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("sharp(QVariantMap)");
        QVariantList __repc_args;
        __repc_args
            << QVariant::fromValue(params)
        ;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void zoom(QVariantMap params)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("zoom(QVariantMap)");
        QVariantList __repc_args;
        __repc_args
            << QVariant::fromValue(params)
        ;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void save(QString file, QVariantMap params, QVariantList projList)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("save(QString,QVariantMap,QVariantList)");
        QVariantList __repc_args;
        __repc_args
            << QVariant::fromValue(file)
            << QVariant::fromValue(params)
            << QVariant::fromValue(projList)
        ;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void manualAlign(QStringList pointCloudsFirst, QVector<QVector3D> refPointsFist, QStringList pointCloudsSecond, QVector<QVector3D> refPointsSecond)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("manualAlign(QStringList,QVector<QVector3D>,QStringList,QVector<QVector3D>)");
        QVariantList __repc_args;
        __repc_args
            << QVariant::fromValue(pointCloudsFirst)
            << QVariant::fromValue(refPointsFist)
            << QVariant::fromValue(pointCloudsSecond)
            << QVariant::fromValue(refPointsSecond)
        ;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void changeTextureContrast(int bright, int contrast, float colorGama)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("changeTextureContrast(int,int,float)");
        QVariantList __repc_args;
        __repc_args
            << QVariant::fromValue(bright)
            << QVariant::fromValue(contrast)
            << QVariant::fromValue(colorGama)
        ;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void exportShareData(CameraPosition camPos, QString operateType)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("exportShareData(CameraPosition,QString)");
        QVariantList __repc_args;
        __repc_args
            << QVariant::fromValue(camPos)
            << QVariant::fromValue(operateType)
        ;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void calibVideoAreaSize(int width, int height)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("calibVideoAreaSize(int,int)");
        QVariantList __repc_args;
        __repc_args
            << QVariant::fromValue(width)
            << QVariant::fromValue(height)
        ;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void editFillHole(int nFileDataType, double dPerimeter, int nLevel, int num, bool markerFlag)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("editFillHole(int,double,int,int,bool)");
        QVariantList __repc_args;
        __repc_args
            << QVariant::fromValue(nFileDataType)
            << QVariant::fromValue(dPerimeter)
            << QVariant::fromValue(nLevel)
            << QVariant::fromValue(num)
            << QVariant::fromValue(markerFlag)
        ;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void applyFillHole(int nFileDataType, double dPerimeter, int nLevel, QVector<unsigned int> holeList, bool markerFlag, bool isConfrimClicked)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("applyFillHole(int,double,int,QVector<uint>,bool,bool)");
        QVariantList __repc_args;
        __repc_args
            << QVariant::fromValue(nFileDataType)
            << QVariant::fromValue(dPerimeter)
            << QVariant::fromValue(nLevel)
            << QVariant::fromValue(holeList)
            << QVariant::fromValue(markerFlag)
            << QVariant::fromValue(isConfrimClicked)
        ;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void loadModel(QString filePath)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("loadModel(QString)");
        QVariantList __repc_args;
        __repc_args
            << QVariant::fromValue(filePath)
        ;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void getAllHoleInfo()
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("getAllHoleInfo()");
        QVariantList __repc_args;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void requestData()
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("requestData()");
        QVariantList __repc_args;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void readDataEnd()
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("readDataEnd()");
        QVariantList __repc_args;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void makePrivateDebugFile()
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("makePrivateDebugFile()");
        QVariantList __repc_args;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void checkPrivateDebugFile()
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("checkPrivateDebugFile()");
        QVariantList __repc_args;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void enterPostDataProcess()
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("enterPostDataProcess()");
        QVariantList __repc_args;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void exitDataPostProcess()
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("exitDataPostProcess()");
        QVariantList __repc_args;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void clearMeshData()
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("clearMeshData()");
        QVariantList __repc_args;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void rebuildTextureMap(bool textureExtend)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("rebuildTextureMap(bool)");
        QVariantList __repc_args;
        __repc_args
            << QVariant::fromValue(textureExtend)
        ;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void startPostProcessMode()
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("startPostProcessMode()");
        QVariantList __repc_args;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void stopPostProcessMode()
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("stopPostProcessMode()");
        QVariantList __repc_args;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void restoreRawMeshData()
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("restoreRawMeshData()");
        QVariantList __repc_args;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void projectCross()
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("projectCross()");
        QVariantList __repc_args;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void cancelManulAlign(QStringList names, QVector<QVector3D> rotX, QVector<QVector3D> rotY, QVector<QVector3D> rotZ, QVector<QVector3D> trans)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("cancelManulAlign(QStringList,QVector<QVector3D>,QVector<QVector3D>,QVector<QVector3D>,QVector<QVector3D>)");
        QVariantList __repc_args;
        __repc_args
            << QVariant::fromValue(names)
            << QVariant::fromValue(rotX)
            << QVariant::fromValue(rotY)
            << QVariant::fromValue(rotZ)
            << QVariant::fromValue(trans)
        ;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void deleteMeshFace()
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("deleteMeshFace()");
        QVariantList __repc_args;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void getPostProcessParam()
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("getPostProcessParam()");
        QVariantList __repc_args;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void hideProject(QVariantMap info)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("hideProject(QVariantMap)");
        QVariantList __repc_args;
        __repc_args
            << QVariant::fromValue(info)
        ;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void removeMultiProjectData(QStringList projectPath, bool isDelete, bool triggerBySelectAll)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("removeMultiProjectData(QStringList,bool,bool)");
        QVariantList __repc_args;
        __repc_args
            << QVariant::fromValue(projectPath)
            << QVariant::fromValue(isDelete)
            << QVariant::fromValue(triggerBySelectAll)
        ;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void alignMultiProject(QStringList projectFix, QVector<QVector3D> fixPos, QStringList projectFloat, QVector<QVector3D> floatPos)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("alignMultiProject(QStringList,QVector<QVector3D>,QStringList,QVector<QVector3D>)");
        QVariantList __repc_args;
        __repc_args
            << QVariant::fromValue(projectFix)
            << QVariant::fromValue(fixPos)
            << QVariant::fromValue(projectFloat)
            << QVariant::fromValue(floatPos)
        ;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void alignMultiProjectWithMarkers(QStringList projectFix, QStringList projectFloat)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("alignMultiProjectWithMarkers(QStringList,QStringList)");
        QVariantList __repc_args;
        __repc_args
            << QVariant::fromValue(projectFix)
            << QVariant::fromValue(projectFloat)
        ;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void alignMultiProjectWithFeature(QStringList projectFix, QStringList projectFloat)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("alignMultiProjectWithFeature(QStringList,QStringList)");
        QVariantList __repc_args;
        __repc_args
            << QVariant::fromValue(projectFix)
            << QVariant::fromValue(projectFloat)
        ;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void cancelAlginMultiProject()
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("cancelAlginMultiProject()");
        QVariantList __repc_args;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void applyAlginMultiProject()
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("applyAlginMultiProject()");
        QVariantList __repc_args;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void meshMultiProject(QVariantMap meshInfo)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("meshMultiProject(QVariantMap)");
        QVariantList __repc_args;
        __repc_args
            << QVariant::fromValue(meshInfo)
        ;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void changeProjName(QString beforeName, QString afterName)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("changeProjName(QString,QString)");
        QVariantList __repc_args;
        __repc_args
            << QVariant::fromValue(beforeName)
            << QVariant::fromValue(afterName)
        ;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void multiProjectGenerateData(QStringList projectPath, bool globalOptimize, float pointDist)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("multiProjectGenerateData(QStringList,bool,float)");
        QVariantList __repc_args;
        __repc_args
            << QVariant::fromValue(projectPath)
            << QVariant::fromValue(globalOptimize)
            << QVariant::fromValue(pointDist)
        ;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void updateAlignIndexAndGroupName(QVariantMap info)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("updateAlignIndexAndGroupName(QVariantMap)");
        QVariantList __repc_args;
        __repc_args
            << QVariant::fromValue(info)
        ;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void openOrCreateSolution(QVariantMap info)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("openOrCreateSolution(QVariantMap)");
        QVariantList __repc_args;
        __repc_args
            << QVariant::fromValue(info)
        ;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void hasGenerateMeshData(QStringList projectPathList, QVector<bool> & dataVec)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("hasGenerateMeshData(QStringList,QVector<bool>&)");
        QVariantList __repc_args;
        __repc_args
            << QVariant::fromValue(projectPathList)
            << QVariant::fromValue(dataVec)
        ;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void updateChangeSign()
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("updateChangeSign()");
        QVariantList __repc_args;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void setAlignGroupInfo(QStringList projectPaths, QVector<int> groupIds)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("setAlignGroupInfo(QStringList,QVector<int>)");
        QVariantList __repc_args;
        __repc_args
            << QVariant::fromValue(projectPaths)
            << QVariant::fromValue(groupIds)
        ;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void getAlignGroupInfo(QStringList & projectPaths, QVector<int> & groupIds)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("getAlignGroupInfo(QStringList&,QVector<int>&)");
        QVariantList __repc_args;
        __repc_args
            << QVariant::fromValue(projectPaths)
            << QVariant::fromValue(groupIds)
        ;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void reconnectDevice()
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("reconnectDevice()");
        QVariantList __repc_args;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void checkFrameMemoryValue(QStringList projectPaths)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("checkFrameMemoryValue(QStringList)");
        QVariantList __repc_args;
        __repc_args
            << QVariant::fromValue(projectPaths)
        ;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    QRemoteObjectPendingReply<QVariantMap> getProjectInfo(QString projectPaths)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("getProjectInfo(QString)");
        QVariantList __repc_args;
        __repc_args
            << QVariant::fromValue(projectPaths)
        ;
        return QRemoteObjectPendingReply<QVariantMap>(sendWithReply(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args));
    }
    void setScanInfo(double expo, double gain, int ledRatio, int laserRatio)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("setScanInfo(double,double,int,int)");
        QVariantList __repc_args;
        __repc_args
            << QVariant::fromValue(expo)
            << QVariant::fromValue(gain)
            << QVariant::fromValue(ledRatio)
            << QVariant::fromValue(laserRatio)
        ;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void setLaserExtractScanInfo(float constrastRatio, float grayDiff)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("setLaserExtractScanInfo(float,float)");
        QVariantList __repc_args;
        __repc_args
            << QVariant::fromValue(constrastRatio)
            << QVariant::fromValue(grayDiff)
        ;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void setClipPlane(QVector3D planeCenter, QVector3D planeNormal, bool useClipPlane, bool deleteSelectData)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("setClipPlane(QVector3D,QVector3D,bool,bool)");
        QVariantList __repc_args;
        __repc_args
            << QVariant::fromValue(planeCenter)
            << QVariant::fromValue(planeNormal)
            << QVariant::fromValue(useClipPlane)
            << QVariant::fromValue(deleteSelectData)
        ;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void setNotifyTotalFrames(bool notify)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("setNotifyTotalFrames(bool)");
        QVariantList __repc_args;
        __repc_args
            << QVariant::fromValue(notify)
        ;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }
    void setCurrentProjectMode(int sType)
    {
        static int __repc_index = ScanServiceReplica::staticMetaObject.indexOfSlot("setCurrentProjectMode(int)");
        QVariantList __repc_args;
        __repc_args
            << QVariant::fromValue(sType)
        ;
        send(QMetaObject::InvokeMetaMethod, __repc_index, __repc_args);
    }

private:
    friend class QT_PREPEND_NAMESPACE(QRemoteObjectNode);
};

#if (QT_VERSION < QT_VERSION_CHECK(5, 5, 0))
    Q_DECLARE_METATYPE(ScanServiceReplica::ErrorCode)
    Q_DECLARE_METATYPE(ScanServiceReplica::DeviceType)
    Q_DECLARE_METATYPE(ScanServiceReplica::DeviceSeries)
    Q_DECLARE_METATYPE(ScanServiceReplica::DeviceSubType)
    Q_DECLARE_METATYPE(ScanServiceReplica::DeviceStatus)
    Q_DECLARE_METATYPE(ScanServiceReplica::DeviceEvent)
    Q_DECLARE_METATYPE(ScanServiceReplica::ScanType)
    Q_DECLARE_METATYPE(ScanServiceReplica::SubScanType)
    Q_DECLARE_METATYPE(ScanServiceReplica::CaliType)
    Q_DECLARE_METATYPE(ScanServiceReplica::AlignType)
    Q_DECLARE_METATYPE(ScanServiceReplica::ScanStatus)
    Q_DECLARE_METATYPE(ScanServiceReplica::MemoryType)
    Q_DECLARE_METATYPE(ScanServiceReplica::MeshType)
    Q_DECLARE_METATYPE(ScanServiceReplica::ModelColorType)
    Q_DECLARE_METATYPE(ScanServiceReplica::ScanObjType)
    Q_DECLARE_METATYPE(ScanServiceReplica::LaserScanType)
    Q_DECLARE_METATYPE(ScanServiceReplica::ScanObjInPortraitModeType)
    Q_DECLARE_METATYPE(ScanServiceReplica::ChangeEventType)
    Q_DECLARE_METATYPE(ScanServiceReplica::AsyncActionType)
    Q_DECLARE_METATYPE(ScanServiceReplica::ServerNotifyType)
#endif

inline QDataStream &operator<<(QDataStream &ds, const ScanServiceReplica::ErrorCode &obj)
{
    quint8 val = obj;
    ds << val;
    return ds;
}

inline QDataStream &operator>>(QDataStream &ds, ScanServiceReplica::ErrorCode &obj) {
    bool ok;
    quint8 val;
    ds >> val;
    obj = ScanServiceReplica::toErrorCode(val, &ok);
    if (!ok)
        qWarning() << "QtRO received an invalid enum value for typeErrorCode, value =" << val;
    return ds;
}

inline QDataStream &operator<<(QDataStream &ds, const ScanServiceReplica::DeviceType &obj)
{
    quint8 val = obj;
    ds << val;
    return ds;
}

inline QDataStream &operator>>(QDataStream &ds, ScanServiceReplica::DeviceType &obj) {
    bool ok;
    quint8 val;
    ds >> val;
    obj = ScanServiceReplica::toDeviceType(val, &ok);
    if (!ok)
        qWarning() << "QtRO received an invalid enum value for typeDeviceType, value =" << val;
    return ds;
}

inline QDataStream &operator<<(QDataStream &ds, const ScanServiceReplica::DeviceSeries &obj)
{
    quint8 val = obj;
    ds << val;
    return ds;
}

inline QDataStream &operator>>(QDataStream &ds, ScanServiceReplica::DeviceSeries &obj) {
    bool ok;
    quint8 val;
    ds >> val;
    obj = ScanServiceReplica::toDeviceSeries(val, &ok);
    if (!ok)
        qWarning() << "QtRO received an invalid enum value for typeDeviceSeries, value =" << val;
    return ds;
}

inline QDataStream &operator<<(QDataStream &ds, const ScanServiceReplica::DeviceSubType &obj)
{
    quint8 val = obj;
    ds << val;
    return ds;
}

inline QDataStream &operator>>(QDataStream &ds, ScanServiceReplica::DeviceSubType &obj) {
    bool ok;
    quint8 val;
    ds >> val;
    obj = ScanServiceReplica::toDeviceSubType(val, &ok);
    if (!ok)
        qWarning() << "QtRO received an invalid enum value for typeDeviceSubType, value =" << val;
    return ds;
}

inline QDataStream &operator<<(QDataStream &ds, const ScanServiceReplica::DeviceStatus &obj)
{
    quint8 val = obj;
    ds << val;
    return ds;
}

inline QDataStream &operator>>(QDataStream &ds, ScanServiceReplica::DeviceStatus &obj) {
    bool ok;
    quint8 val;
    ds >> val;
    obj = ScanServiceReplica::toDeviceStatus(val, &ok);
    if (!ok)
        qWarning() << "QtRO received an invalid enum value for typeDeviceStatus, value =" << val;
    return ds;
}

inline QDataStream &operator<<(QDataStream &ds, const ScanServiceReplica::DeviceEvent &obj)
{
    qint8 val = obj;
    ds << val;
    return ds;
}

inline QDataStream &operator>>(QDataStream &ds, ScanServiceReplica::DeviceEvent &obj) {
    bool ok;
    qint8 val;
    ds >> val;
    obj = ScanServiceReplica::toDeviceEvent(val, &ok);
    if (!ok)
        qWarning() << "QtRO received an invalid enum value for typeDeviceEvent, value =" << val;
    return ds;
}

inline QDataStream &operator<<(QDataStream &ds, const ScanServiceReplica::ScanType &obj)
{
    quint8 val = obj;
    ds << val;
    return ds;
}

inline QDataStream &operator>>(QDataStream &ds, ScanServiceReplica::ScanType &obj) {
    bool ok;
    quint8 val;
    ds >> val;
    obj = ScanServiceReplica::toScanType(val, &ok);
    if (!ok)
        qWarning() << "QtRO received an invalid enum value for typeScanType, value =" << val;
    return ds;
}

inline QDataStream &operator<<(QDataStream &ds, const ScanServiceReplica::SubScanType &obj)
{
    quint8 val = obj;
    ds << val;
    return ds;
}

inline QDataStream &operator>>(QDataStream &ds, ScanServiceReplica::SubScanType &obj) {
    bool ok;
    quint8 val;
    ds >> val;
    obj = ScanServiceReplica::toSubScanType(val, &ok);
    if (!ok)
        qWarning() << "QtRO received an invalid enum value for typeSubScanType, value =" << val;
    return ds;
}

inline QDataStream &operator<<(QDataStream &ds, const ScanServiceReplica::CaliType &obj)
{
    quint8 val = obj;
    ds << val;
    return ds;
}

inline QDataStream &operator>>(QDataStream &ds, ScanServiceReplica::CaliType &obj) {
    bool ok;
    quint8 val;
    ds >> val;
    obj = ScanServiceReplica::toCaliType(val, &ok);
    if (!ok)
        qWarning() << "QtRO received an invalid enum value for typeCaliType, value =" << val;
    return ds;
}

inline QDataStream &operator<<(QDataStream &ds, const ScanServiceReplica::AlignType &obj)
{
    quint8 val = obj;
    ds << val;
    return ds;
}

inline QDataStream &operator>>(QDataStream &ds, ScanServiceReplica::AlignType &obj) {
    bool ok;
    quint8 val;
    ds >> val;
    obj = ScanServiceReplica::toAlignType(val, &ok);
    if (!ok)
        qWarning() << "QtRO received an invalid enum value for typeAlignType, value =" << val;
    return ds;
}

inline QDataStream &operator<<(QDataStream &ds, const ScanServiceReplica::ScanStatus &obj)
{
    quint8 val = obj;
    ds << val;
    return ds;
}

inline QDataStream &operator>>(QDataStream &ds, ScanServiceReplica::ScanStatus &obj) {
    bool ok;
    quint8 val;
    ds >> val;
    obj = ScanServiceReplica::toScanStatus(val, &ok);
    if (!ok)
        qWarning() << "QtRO received an invalid enum value for typeScanStatus, value =" << val;
    return ds;
}

inline QDataStream &operator<<(QDataStream &ds, const ScanServiceReplica::MemoryType &obj)
{
    quint8 val = obj;
    ds << val;
    return ds;
}

inline QDataStream &operator>>(QDataStream &ds, ScanServiceReplica::MemoryType &obj) {
    bool ok;
    quint8 val;
    ds >> val;
    obj = ScanServiceReplica::toMemoryType(val, &ok);
    if (!ok)
        qWarning() << "QtRO received an invalid enum value for typeMemoryType, value =" << val;
    return ds;
}

inline QDataStream &operator<<(QDataStream &ds, const ScanServiceReplica::MeshType &obj)
{
    quint8 val = obj;
    ds << val;
    return ds;
}

inline QDataStream &operator>>(QDataStream &ds, ScanServiceReplica::MeshType &obj) {
    bool ok;
    quint8 val;
    ds >> val;
    obj = ScanServiceReplica::toMeshType(val, &ok);
    if (!ok)
        qWarning() << "QtRO received an invalid enum value for typeMeshType, value =" << val;
    return ds;
}

inline QDataStream &operator<<(QDataStream &ds, const ScanServiceReplica::ModelColorType &obj)
{
    qint8 val = obj;
    ds << val;
    return ds;
}

inline QDataStream &operator>>(QDataStream &ds, ScanServiceReplica::ModelColorType &obj) {
    bool ok;
    qint8 val;
    ds >> val;
    obj = ScanServiceReplica::toModelColorType(val, &ok);
    if (!ok)
        qWarning() << "QtRO received an invalid enum value for typeModelColorType, value =" << val;
    return ds;
}

inline QDataStream &operator<<(QDataStream &ds, const ScanServiceReplica::ScanObjType &obj)
{
    qint8 val = obj;
    ds << val;
    return ds;
}

inline QDataStream &operator>>(QDataStream &ds, ScanServiceReplica::ScanObjType &obj) {
    bool ok;
    qint8 val;
    ds >> val;
    obj = ScanServiceReplica::toScanObjType(val, &ok);
    if (!ok)
        qWarning() << "QtRO received an invalid enum value for typeScanObjType, value =" << val;
    return ds;
}

inline QDataStream &operator<<(QDataStream &ds, const ScanServiceReplica::LaserScanType &obj)
{
    quint8 val = obj;
    ds << val;
    return ds;
}

inline QDataStream &operator>>(QDataStream &ds, ScanServiceReplica::LaserScanType &obj) {
    bool ok;
    quint8 val;
    ds >> val;
    obj = ScanServiceReplica::toLaserScanType(val, &ok);
    if (!ok)
        qWarning() << "QtRO received an invalid enum value for typeLaserScanType, value =" << val;
    return ds;
}

inline QDataStream &operator<<(QDataStream &ds, const ScanServiceReplica::ScanObjInPortraitModeType &obj)
{
    quint8 val = obj;
    ds << val;
    return ds;
}

inline QDataStream &operator>>(QDataStream &ds, ScanServiceReplica::ScanObjInPortraitModeType &obj) {
    bool ok;
    quint8 val;
    ds >> val;
    obj = ScanServiceReplica::toScanObjInPortraitModeType(val, &ok);
    if (!ok)
        qWarning() << "QtRO received an invalid enum value for typeScanObjInPortraitModeType, value =" << val;
    return ds;
}

inline QDataStream &operator<<(QDataStream &ds, const ScanServiceReplica::ChangeEventType &obj)
{
    quint8 val = obj;
    ds << val;
    return ds;
}

inline QDataStream &operator>>(QDataStream &ds, ScanServiceReplica::ChangeEventType &obj) {
    bool ok;
    quint8 val;
    ds >> val;
    obj = ScanServiceReplica::toChangeEventType(val, &ok);
    if (!ok)
        qWarning() << "QtRO received an invalid enum value for typeChangeEventType, value =" << val;
    return ds;
}

inline QDataStream &operator<<(QDataStream &ds, const ScanServiceReplica::AsyncActionType &obj)
{
    quint8 val = obj;
    ds << val;
    return ds;
}

inline QDataStream &operator>>(QDataStream &ds, ScanServiceReplica::AsyncActionType &obj) {
    bool ok;
    quint8 val;
    ds >> val;
    obj = ScanServiceReplica::toAsyncActionType(val, &ok);
    if (!ok)
        qWarning() << "QtRO received an invalid enum value for typeAsyncActionType, value =" << val;
    return ds;
}

inline QDataStream &operator<<(QDataStream &ds, const ScanServiceReplica::ServerNotifyType &obj)
{
    quint8 val = obj;
    ds << val;
    return ds;
}

inline QDataStream &operator>>(QDataStream &ds, ScanServiceReplica::ServerNotifyType &obj) {
    bool ok;
    quint8 val;
    ds >> val;
    obj = ScanServiceReplica::toServerNotifyType(val, &ok);
    if (!ok)
        qWarning() << "QtRO received an invalid enum value for typeServerNotifyType, value =" << val;
    return ds;
}


QT_BEGIN_NAMESPACE
QT_END_NAMESPACE


#endif // REP_SCANSERVICE_REPLICA_H
